(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.draco = {})));
}(this, (function (exports) { 'use strict';

    const REGEX = /(\w+)\(([\w\.\/]+)(,([\w\.]+))?\)/;
    /**
     * Convert from ASP to Vega-Lite.
     */
    function asp2vl(facts) {
        let mark = '';
        let url = 'data/cars.json'; // default dataset
        const encodings = {};
        for (const value of facts) {
            // TODO: Better handle quoted fields. We currently simply remove all ".
            const cleanedValue = value.replace(/\"/g, '');
            const negSymbol = value.trim().startsWith(':-'); // TODO: remove this
            const [_, predicate, first, __, second] = REGEX.exec(cleanedValue);
            if (predicate === 'mark') {
                mark = first;
            }
            else if (predicate === 'data') {
                url = first;
            }
            else if (predicate !== 'soft') {
                if (!encodings[first]) {
                    encodings[first] = {};
                }
                // if it contains the neg symbol, and the field is a boolean field, its value would be false
                // e.g., for the case ":- zero(e3)"
                encodings[first][predicate] = second || !negSymbol;
            }
        }
        const encoding = {};
        for (const e of Object.keys(encodings)) {
            const enc = encodings[e];
            // if quantitative encoding and zero is not set, set zero to false
            if (enc.type === 'quantitative' && enc.zero === undefined && enc.bin === undefined) {
                enc.zero = false;
            }
            const scale = {
                ...(enc.log ? { type: 'log' } : {}),
                ...(enc.zero === undefined ? {} : enc.zero ? { zero: true } : { zero: false }),
            };
            encoding[enc.channel] = {
                type: enc.type,
                ...(enc.aggregate ? { aggregate: enc.aggregate } : {}),
                ...(enc.field ? { field: enc.field } : {}),
                ...(enc.stack ? { stack: enc.stack } : {}),
                ...(enc.bin !== undefined ? (+enc.bin === 10 ? { bin: true } : { bin: { maxbins: +enc.bin } }) : {}),
                ...(Object.keys(scale).length ? { scale } : {}),
            };
        }
        return {
            $schema: 'https://vega.github.io/schema/vega-lite/v3.json',
            data: { url: `${url}` },
            mark,
            encoding,
        };
    }

    // GENERATED WITH concat_lp.sh. DO NOT MODIFY.
    const TOPK_LUA = `#script(lua)

function main(prg)
    local count = tonumber(prg.configuration.solve.models)
    local backend = prg:backend()

    local observer = {
        minimize_literals = {}
    }
    function observer:minimize (priority, literals)
        self.minimize_literals = literals
    end

    prg:register_observer(observer)

    prg:ground({{"base", {}}}, self)

    while count > 0 do
        local cost = 0

        prg.configuration.solve.models = count
        local it = prg:solve{yield=true}
        local ret, err = pcall(function()
            if it:get().unsatisfiable then
                count = 0
                return
            end

            for m in it:iter() do
                if m.optimality_proven then
                    cost = m.cost[1]
                    count = count-1
                end
            end
        end)
        it:close()
        if not ret then
            error(err)
        end

        if count > 0 then
            local aux = backend:add_atom()
            backend:add_weight_rule{{aux}, cost+1, observer.minimize_literals}
            backend:add_rule{{aux}, {-aux}}
        end
    end
end
#end.

`;
    const DEFINE = `% ====== Definitions ======

% Types of marks to encode data.
marktype(point;bar;line;area;text;tick;rect).
% High level data types: quantitative, ordinal, nominal, temporal.
type(quantitative;ordinal;nominal;temporal).
% Basic types of the data.
primitive_type(string;number;boolean;datetime).
% Supported aggregation functions.
aggregate_op(count;mean;median;min;max;stdev;sum).
summative_aggregate_op(count;sum).
% Numbers of bins that can be recommended; any natural number is allowed.
binning(10;25;200).

% Encoding channels.
single_channel(x;y;color;size;shape;text;row;column).
multi_channel(detail).
channel(C) :- single_channel(C).
channel(C) :- multi_channel(C).
non_positional(color;size;shape;text;detail).

% Possible tasks.
tasks(value;summary).

% Possible stackings.
stacking(zero;normalize).

% ====== Helpers ======

discrete(E) :- type(E,(nominal;ordinal)).
discrete(E) :- bin(E,_).
continuous(E) :- encoding(E), not discrete(E).

channel_discrete(C) :- discrete(E), channel(E,C).
channel_continuous(C) :- continuous(E), channel(E,C).

ordered(E) :- type(E,(ordinal;quantitative)).

% Fields
field(F) :- fieldtype(F,_).

% Stacking is applied to the continuous x or y.
stack(EC,S) :- channel(EC,(x;y)), channel(ED,(x;y)), continuous(EC), discrete(ED), stack(S).
% X and y are continuous.
stack(E,S) :- channel_continuous(x), channel(E,y), continuous(E), stack(S).

stack(S) :- stack(_,S).

% Data properties
enc_cardinality(E,C) :- field(E,F), cardinality(F,C).
enc_entropy(E,EN) :- field(E,F), entropy(F,EN).
enc_interesting(E) :- field(E,F), interesting(F).
enc_extent(E,MIN,MAX) :- field(E,F), extent(F,MIN,MAX).

% Cardinality of discrete field. A binned field has the cadinality of its field.
discrete_cardinality(E,CE) :- discrete(E), enc_cardinality(E,CE), channel(E,C), not bin(E,_).
discrete_cardinality(E,CB) :- channel(E,C), bin(E,CB).

% Define a fake soft/2 for all soft/1.
soft(F,_placeholder) :- soft(F).

% Silence warnings about properties never appearing in head.
entropy(0,0) :- #false.
interesting(0) :- #false.
extent(0,0,0) :- #false.
soft(0) :- #false.
task(value) :- #false.
task(summary) :- #false.
data(0) :- #false.

% == Chart Types ==

% Continuous by continuous.
is_c_c :- channel_continuous(x), channel_continuous(y).

% Continuous by discrete (or continuous only).
is_c_d :- channel_continuous(x), not channel_continuous(y).
is_c_d :- channel_continuous(y), not channel_continuous(x).

% Discrete by discrete.
is_d_d :- channel_discrete(x), channel_discrete(y).

% == Overlap ==

% The continuous variable is a measure (it is aggregated) and all other channels are .aggregated, or we use stack -> no overlap
non_pos_unaggregated :- channel(E,C), non_positional(C), not aggregate(E,_).
no_overlap :- is_c_d, continuous(E), channel(E,(x;y)), aggregate(E,_), not non_pos_unaggregated.
no_overlap :- is_c_d, stack(_).

% the size of the discrete positional encoding
discrete_size(S) :- is_c_d, x_y_cardinality(_,S).
discrete_size(1) :- is_c_d, channel_continuous(x), not channel(_,y).
discrete_size(1) :- is_c_d, channel_continuous(y), not channel(_,x).

% Data size is as small as discrete dimension -> no overlap.
no_overlap :- is_c_d, num_rows(S), discrete_size(S).

% We definitely overlap if the data size > discrete size.
overlap :- is_c_d, not no_overlap, num_rows(S1), discrete_size(S2), S1 > S2.

% helpers to go from quadratic to linear number of grounding
x_y_cardinality(x,S) :- channel(E,x), discrete_cardinality(E,S).
x_y_cardinality(y,S) :- channel(E,y), discrete_cardinality(E,S).

% No overlap if all other dimensions are aggregated.
discrete_size(S) :- is_d_d, x_y_cardinality(x,SX), x_y_cardinality(y,SY), S = SX*SY.
no_overlap :- is_d_d, not non_pos_unaggregated.
no_overlap :- is_d_d, num_rows(S1), discrete_size(S2), S1 <= S2.  % This cannot guarantee no overlap.

% We can guarantee overlap using this rule unless we are using row / column.
row_col :- channel(_,(row;column)).
overlap :- is_d_d, channel(E,C), not row_col, not no_overlap, num_rows(S1), discrete_size(S2), S1 > S2.

% == Orientation ==

% Orientation tells us which one is the dependent and independent variable.

orientation(vertical) :- mark(bar;tick;area;line), channel_discrete(x).
orientation(vertical) :- mark(area;line), channel_continuous(x), channel_continuous(y).

orientation(horizontal) :- mark(bar;tick;area;line), channel_discrete(y).

`;
    const GENERATE = `% ====== Generators ======

% encodings

% maximum number for each multi channel encoding
#const max_extra_encs = 5.

obj_id(1..max_extra_encs).

{ encoding(E): obj_id(E) }.

:- not encoding(ID), encoding(ID-1), obj_id(ID), obj_id(ID-1).

% properties of encodings

% channel and type have to be present
{ channel(E,C): channel(C) } = 1 :- encoding(E).
{ type(E,T): type(T) } = 1 :- encoding(E).

% other properties that are not required
0 { field(E,F): field(F) } 1 :- encoding(E).
0 { aggregate(E,A): aggregate_op(A) } 1 :- encoding(E).
0 { bin(E,B): binning(B) } 1 :- encoding(E).
0 { zero(E) } 1 :- encoding(E).
0 { log(E) } 1 :- encoding(E).

% pick one mark type

{ mark(M) : marktype(M) } = 1.

% stacking

0 { stack(S): stacking(S) } 1.

`;
    const HARD = `% ====== Expressiveness and Well-Formedness Constraints ======

% === Within Encodings ===

% @constraint Primitive type has to support data type.
hard(enc_type_valid,E,F) :- type(E,quantitative), field(E,F), fieldtype(F,(string;boolean)).
hard(enc_type_valid,E,F) :- type(E,temporal), field(E,F), not fieldtype(F,datetime).

% @constraint Can only bin quantitative or ordinal.
hard(bin_q_o,E,T) :- type(E,T), bin(E,_), T != quantitative, T != ordinal.

% @constraint Can only use log with quantitative.
hard(log_q,E) :- log(E), not type(E,quantitative).

% @constraint Can only use zero with quantitative.
hard(zero_q,E) :- zero(E), not type(E,quantitative).

% @constraint Cannot use log scale with discrete (which includes binned).
hard(log_discrete,E) :- log(E), discrete(E).

% @constraint Cannot use log and zero together.
hard(log_zero,E) :- log(E), zero(E).

% @constraint Cannot use log if the data is negative or zero.
hard(log_non_positive,E,F) :- log(E), field(E,F), extent(F,MIN,_), MIN <= 0.

% @constraint Cannot bin and aggregate.
hard(bin_and_aggregate,E) :- bin(E,_), aggregate(E,_).

% @constraint Oridnal only supports min, max, and median.
hard(aggregate_o_valid,E,A) :- type(E,ordinal), aggregate(E,A), A != min, A != max, A != median.

% @constraint Temporal only supports min and max.
hard(aggregate_t_valid,E,A) :- type(E,temporal), aggregate(E,A), A != min, A != max.

% @constraint Cannot aggregate nominal.
hard(aggregate_nominal,E) :- aggregate(E,_), type(E,nominal).

% @constraint Detail cannot be aggregated.
hard(aggregate_detail,E) :- channel(E,detail), aggregate(E,_).

% @constraint Count has to be quantitative and not use a field.
hard(count_q_without_field,E) :- aggregate(E,count), field(E,_).
hard(count_q_without_field,E) :- aggregate(E,count), not type(E,quantitative).

% @constraint Shape requires discrete and not ordered (nominal). Using ordinal would't make a difference in Vega-Lite.
hard(shape_discrete_non_ordered,E) :- channel(E,shape), not type(E,nominal).

% @constraint Detail requires nominal.
hard(detail_non_ordered,E) :- channel(E,detail), not type(E,nominal).

% @constraint Size implies order so nominal is misleading.
hard(size_nominal) :- channel(E,size), type(E,nominal).

% @constraint Do not use size when data is negative as size implies that data is positive.
hard(size_negative,E) :- channel(E,size), enc_extent(E,MIN,MAX), MIN < 0, MAX > 0.

% === Across encodings and between encodings and marks ===

% @constraint Cannot use single channels twice.
hard(repeat_channel,C):- single_channel(C), 2 { channel(_,C) }.

% @constraint There has to be at least one encoding. Otherwise, the visualization doesn't show anything.
hard(no_encodings) :- not encoding(_).

% @constraint Row and column require discrete.
hard(row_or_column_c) :- channel_continuous(row;column).

% @constraint Don't use row without y. Just using y is simpler.
hard(row_no_y) :- channel(_,row), not channel(_,y).

% @constraint Don't use column without x. Just using x is simpler.
hard(column_no_x) :- channel(_,column), not channel(_,x).

% @constraint All encodings (if they have a channel) require field except if we have a count aggregate.
hard(encoding_no_field_and_not_count,E) :- not field(E,_), not aggregate(E,count), encoding(E).

% @constraint Count should not have a field. Having a field doesn't make a difference.
hard(count_with_field,E) :- aggregate(E,count), field(E,_).

% @constraint Text mark requires text channel.
hard(text_mark_without_text_channel) :- mark(text), not channel(_,text).

% @constraint Text channel requires text mark.
hard(text_channel_without_text_mark) :- channel(_,text), not mark(text).

% @constraint Point, tick, and bar require x or y channel.
hard(point_tick_bar_without_x_or_y) :- mark(point;tick;bar), not channel(_,x), not channel(_,y).

% @constraint Line and area require x and y channel.
hard(line_area_without_x_y) :- mark(line;area), not channel(_,(x;y)).

% @constraint Line and area cannot have two discrete.
hard(line_area_with_discrete) :- mark(line;area), channel_discrete(x), channel_discrete(y).

% @constraint Bar and tick cannot have both x and y continuous.
hard(bar_tick_continuous_x_y) :- mark(bar;tick), channel_continuous(x), channel_continuous(y).

% @constraint Bar, tick, line, area require some continuous variable on x or y.
hard(bar_tick_area_line_without_continuous_x_y) :- mark(bar;tick;area;line), not channel_continuous(x), not channel_continuous(y).

% @constraint Bar and area mark requires scale of continuous to start at zero.
hard(bar_area_without_zero) :- mark(bar;area), channel(E,x), orientation(horizontal), not zero(E).
hard(bar_area_without_zero) :- mark(bar;area), channel(E,y), orientation(vertical), not zero(E).

% @constraint Shape channel requires point mark.
hard(shape_without_point) :- channel(_,shape), not mark(point).

% @constraint Size only works with some marks. Vega-Lite can also size lines, and ticks but that would violate best practices.
hard(size_without_point_text) :- channel(_,size), not mark(point), not mark(text).

% @constraint Detail requires aggregation. Detail adds a field to the group by. Detail could also be used to add information to tooltips. We may remove this later.
hard(detail_without_agg) :- channel(_,detail), not aggregate(_,_).

% @constraint Do not use log for bar or area mark as they are often misleading. We may remove this rule in the future.
hard(area_bar_with_log) :- mark(bar;area), log(E), channel(E,(x;y)).

% @constraint Rect mark needs discrete x and y.
hard(rect_without_d_d) :- mark(rect), not is_d_d.

% @constraint Don't use the same field on x and y.
hard(same_field_x_and_y) :- { field(E,F) : channel(E,x); field(E,F) : channel(E,y) } >= 2, field(F).

% @constraint Don't use count on x and y.
hard(count_on_x_and_y):- channel(EX,x), channel(EY,y), aggregate(EX,count), aggregate(EY,count).

% @constraint If we use aggregation, then all continuous fields need to be aggeragted.
hard(aggregate_not_all_continuous):- aggregate(_,_), continuous(E), not aggregate(E,_).

% @constraint Don't use count twice.
hard(count_twice) :- { aggregate(_,count) } = 2.

% === Global properties ===

% @constraint Bars and area cannot overlap.
hard(bar_area_overlap) :- mark(bar;area), overlap.

% @constraint Rects shouldn't overlap. They are used for dioscrete heatmaps.
hard(rect_overlap) :- mark(rect), overlap.

% == Stacking ==

% @constraint Only use stacking for bar and area.
hard(stack_without_bar_area) :- stack(_), not mark(bar), not mark(area).

% @constraint Don't stack if aggregation is not summative (summative are count, sum, distinct, valid, missing).
hard(stack_without_summative_agg,E,A) :- stack(E,_), aggregate(E,A), not summative_aggregate_op(A).

% @constraint Need to stack if we use bar, area with discrete color.
hard(no_stack_with_bar_area_discrete_color,E) :- mark(bar;area), channel(E,color), discrete(E), not stack(_).

% @constraint Can only use stack if we also use discrete color, or detail.
hard(stack_without_discrete_color_or_detail) :- stack(_), not channel_discrete(color), not channel(_,detail).

% @constraint If we use stack and detail, we also have to use quantitative color.
hard(stack_detail_without_q_color) :- stack(_), channel(_,detail), not channel(_,color).
hard(stack_detail_without_q_color,E) :- stack(_), channel(_,detail), channel(E,color), not aggregate(E,_).

% @constraint Stack can only be on continuous.
hard(stack_discrete,E) :- stack(E,_), discrete(E).

% @constraint Stack can only be on x or y.
hard(stack_without_x_y,E) :- stack(E,_), not channel(E,x), not channel(E,y).

% @constraint Cannot use non positional continuous with stack unless it's aggregated.
hard(stack_with_non_positional_non_agg,E,C) :- stack(_), non_positional(C), channel(E,C), not aggregate(E,_), continuous(E).

% @constraint Vega-Lite currently supports 8 shapes.
hard(shape_with_cardinality_gt_eight,E,C) :- channel(E,shape), enc_cardinality(E,C), C > 8.

% @constraint At most 20 categorical colors.
hard(color_with_cardinality_gt_twenty,E,C) :- channel(E,color), discrete(E), enc_cardinality(E,C), C > 20.

% === Type checks ===

% @constraint Check mark.
hard(invalid_mark,M) :- mark(M), not marktype(M).

% @constraint Check types of encoding properties.
hard(invalid_channel,C) :- channel(_,C), not channel(C).
hard(invalid_field,F) :- field(_,F), not field(F).
hard(invalid_type,T) :- type(_,T), not type(T).
hard(invalid_agg,A) :- aggregate(_,A), not aggregate_op(A).
hard(invalid_bin,B) :- bin(_,B), not B >= 0.  % @constraint Bin has to be a natural number.

% @constraint Fieldtype has to be primitive type.
hard(invalid_fieldtype,T) :- fieldtype(_,T), not primitive_type(T).

% @constraint Task has to be one of the tasks.
hard(invalid_task,T) :- task(T), not tasks(T).

% @constraint Num_rows has to be larger than 0.
hard(invalid_num_rows,S) :- num_rows(S), S < 0.

% @constraint Cardinality has to be larger than 0.
hard(invalid_cardinality,C) :- cardinality(_,C), C < 0.

% @constraint Entropy has to be positive.
hard(invalid_entropy,E) :- entropy(_,E), E < 0.

% @constraint Extent only allowed for numbers (for now).
hard(invalid_extent_non_number,F) :- extent(F,_,_), not fieldtype(F,number).

% @constraint Order has to be correct.
hard(invalid_extent_order,MIN,MAX):- extent(_,MIN,MAX), MIN > MAX.

% @constraint The name of a field cannot be the name of an encoding. This is to prevent errors coming from the shortcuts in define.lp.
hard(encoding_field_same_name,N) :- encoding(N), field(N).

`;
    const HARD_INTEGRITY = `:- hard(_).
:- hard(_,_).
:- hard(_,_,_).

`;
    const SOFT = `% After adding a soft constraint to this file, make sure to update 'weights.lp' and run 'process_softs.py'..

% ====== Preferences ======

% @constraint Prefer to use raw (no aggregate).
soft(aggregate,E) :- aggregate(E,_).

% @constraint Prefer to not bin.
soft(bin,E) :- bin(E,_).

% @constraint Prefer binning with at most 12 buckets.
soft(bin_high,E) :- bin(E,B), B > 12.

% @constraint Prefer binning with more than 7 buckets.
soft(bin_low,E) :- bin(E,B), B <= 7.

% @constraint Prefer to use fewer encodings.
soft(encoding,E) :- encoding(E).

% @constraint Prefer to use fewer encodings with fields (count does not have a field).
soft(encoding_field,E) :- encoding(E), field(E,_).

% @constraint Prefer not to use the same field twice.
soft(same_field_2,F) :- field(F), { field(_,F) } = 2.

% @constraint Prefer not to use the same field three or more times.
% @weight {16}
soft(same_field_gte3,F) :- field(F), { field(_,F) } >= 3.
% @end

% @constraint Prefer not to use count more than once.
soft(count_twice) :- { aggregate(_,count) } = 2.

% @constraint Shape channel should not have too high cardinality.
soft(shape_cardinality,E) :- channel(E,shape), discrete_cardinality(E,C), C > 5.

% @constraint Numbers should not be nominal.
soft(number_nominal,E) :- type(E,nominal), field(E,F), fieldtype(F,number).

% @constraint Prefer nominal string fields
soft(string_non_nominal,V,E) :- type(V,E,ordinal), field(V,E,F), fieldtype(F,string).
soft(string_non_nominal,V,E) :- type(V,E,temporal), field(V,E,F), fieldtype(F,string).
soft(string_non_nominal,V,E) :- type(V,E,quantitative), field(V,E,F), fieldtype(F,string).

% @constraint Binned quantitative field should not have too low cardinality.
soft(bin_cardinality,E) :- type(E,quantitative), bin(E,_), enc_cardinality(E,C), C < 15.

% @constraint Prefer quantitative for bin.
soft(quant_bin,E) :- bin(E,_), not type(E,quantitative).

% @constraint Plots with only nominal, ordinal, binned q, or t with time unit should add either an aggregation (e.g. count) or a quantitative field.
soft(only_discrete) :- not continuous(_).

% @constraint Prefer not to use multiple non-positional encoding channels.
soft(multiple_non_pos) :- {channel(_,C): non_positional(C)} > 1.

% @constraint Prefer not to use non-positional channels until all positional channels are used.
soft(non_positional_pref) :- channel(_,C), non_positional(C), not channel(_,(x;y)).

% @constraint Aggregate plots should not use raw continuous as group by.
soft(aggregate_group_by_raw,E) :- aggregate(_,_), continuous(E), not aggregate(E,_).

% @constraint Aggregate should also have a discrete encoding to group by.
soft(agg_dim) :- aggregate(_,_), not discrete(_).

% @constraint Prefer not to use plot with both x and y discrete and no aggregate as it leads to occlusion.
soft(x_y_raw,E) :- channel(EX,x), discrete(EX), channel(EY,y), discrete(EY), not aggregate(E,_), continuous(E).

% @constraint Prefer not to use log scale.
soft(log,E) :- log(E).

% @constraint Prefer to include zero for continuous (binned doesn't need zero).
soft(zero,E) :- continuous(E), not zero(E).

% @constraint Prefer zero size (even when binned).
soft(zero_size) :- channel(E,size), not zero(E).

% @constraint Prefer zero positional.
soft(zero_positional) :- continuous(E), channel(E,(x;y)), not zero(E).

% @constraint Prefer not to use zero when the difference between min and max is larger than distance to 0.
soft(zero_skew) :- enc_extent(E,MIN,MAX), EX = MAX - MIN, |MAX| > EX, |MIN| > EX, zero(E).

% @constraint Do not include zero when the range of data includes zero.
soft(includes_zero) :- zero(E), extent(E,MIN,MAX), MIN < 0, MAX > 0.

% @constraint Prefer to use only x instead of only y.
soft(only_x) :- channel(_,y), not channel(_,x).

% @constraint Chart orientation for bar and tick (with and without bin). Binned fields have short labels if they are quantitative while otherwise labels can be long.
soft(orientation_binned) :- bin(E,_), type(E,quantitative), not channel(E,x).

% @constraint Prefer not to use ordinal for fields with high cardinality.
soft(high_cardinality_ordinal,E) :- type(E,ordinal), discrete_cardinality(E,C), C > 30.

% @constraint Prefer not to use nominal for fields with high cardinality.
soft(high_cardinality_nominal,E) :- type(E,nominal), enc_cardinality(E,C), C > 12.

% @constraint Prefer not to use high cardinality nominal for color.
soft(high_cardinality_nominal_color,E) :- type(E,nominal), channel(E,color), enc_cardinality(E,C), C > 10.

% @constraint Avoid high cardinality on x or column as it causes horizontal scrolling.
soft(horizontal_scrolling,E) :- channel(E,x), discrete_cardinality(E,C), C > 50.
soft(horizontal_scrolling,E) :- channel(E,columm), discrete_cardinality(E,C), C > 5.

% @constraint Prefer to use temporal type with dates.
soft(temporal_date,E) :- field(E,F), fieldtype(F,datetime), not type(E,temporal).

% @constraint Prefer quantitative for numbers with high cardinality.
soft(quantitative_numbers) :- field(E,F), fieldtype(F,number), cardinality(F,C), C > 20, not bin(E,_), not type(E,quantitative).

% @constraint Overplotting. Prefer not to use x and y for continuous with high cardinality and low entropy without aggregation because the points will overplot.
soft(position_entropy,E) :- channel(E,(x;y)), continuous(E), enc_cardinality(E,C), C > 100, enc_entropy(E,EN), EN <= 12, not aggregate(E,_).

% @constraint Prefer not to use size when the cardinality is large on x or y.
soft(high_cardinality_size,E) :- continuous(E), channel(_,size), enc_cardinality(E,C), C > 100, channel(E,(x;y)).

% @constraint Prefer not to aggregate for value tasks.
soft(value_agg) :- task(value), aggregate(_,_).

% @constraint Prefer not to use row and column for summary tasks as it makes it difficult to compare.
soft(facet_summary,E) :- task(summary), channel(E,row).

% @constraint Positional interactions as suggested by Kim et al.
soft(x_row) :- channel(_,x), channel(_,row).

% @constraint Positional interactions as suggested by Kim et al.
soft(y_row) :- channel(_,y), channel(_,row).

% @constraint Positional interactions as suggested by Kim et al.
soft(x_column) :- channel(_,x), channel(_,column).

% @constraint Positional interactions as suggested by Kim et al.
soft(y_column) :- channel(_,y), channel(_,column).

% @constraint Entropy, primary quantitaty interactions as suggested by Kim et al.
soft(color_entropy_high, E) :- channel(E,color), enc_entropy(E,EN), EN > 12, type(E,quantitative), enc_interesting(E).

% @constraint Entropy, primary quantitaty interactions as suggested by Kim et al.
soft(color_entropy_low, E) :- channel(E,color), enc_entropy(E,EN), EN <= 12, type(E,quantitative), enc_interesting(E).

% @constraint Entropy, primary quantitaty interactions as suggested by Kim et al.
soft(size_entropy_high, E) :- channel(E,size), enc_entropy(E,EN), EN > 12, type(E,quantitative), enc_interesting(E).

% @constraint Entropy, primary quantitaty interactions as suggested by Kim et al.
soft(size_entropy_low, E) :- channel(E,size), enc_entropy(E,EN), EN <= 12, type(E,quantitative), enc_interesting(E).

% @constraint Prefer not to use continuous on x, discrete on y, and column.
soft(c_d_column) :- channel_continuous(x), channel_discrete(y), channel(_,column).

% @constraint Prefer time on x.
soft(temporal_y) :- type(E,temporal), not channel(E,x).

% @constraint Prefer not to overlap with DxD.
soft(d_d_overlap) :- is_d_d, overlap.

% ====== Rankings ======
% === Data Types ===

% @constraint Prefer quantitative > ordinal > nominal.
soft(type_q,E) :- type(E,quantitative).

% @constraint Prefer quantitative > ordinal > nominal.
soft(type_o,E) :- type(E,ordinal).

% @constraint Prefer quantitative > ordinal > nominal.
soft(type_n,E) :- type(E,nominal).

% === Mark types ===

% @constraint Continuous by continuous for point mark.
soft(c_c_point) :- is_c_c, mark(point).

% @constraint Continuous by continuous for line mark.
soft(c_c_line) :- is_c_c, mark(line).

% @constraint Continuous by continuous for area mark.
soft(c_c_area) :- is_c_c, mark(area).

% @constraint Continuous by continuous for text mark.
soft(c_c_text) :- is_c_c, mark(text).

% @constraint Continuous by continuous for tick mark.
soft(c_c_tick) :- is_c_c, mark(tick).

% @constraint Continuous by discrete for point mark.
soft(c_d_point) :- is_c_d, not no_overlap, mark(point).

% @constraint Continuous by discrete for bar mark.
soft(c_d_bar) :- is_c_d, not no_overlap, mark(bar).

% @constraint Continuous by discrete for line mark.
soft(c_d_line) :- is_c_d, not no_overlap, mark(line).

% @constraint Continuous by discrete for area mark.
soft(c_d_area) :- is_c_d, not no_overlap, mark(area).

% @constraint Continuous by discrete for text mark.
soft(c_d_text) :- is_c_d, not no_overlap, mark(text).

% @constraint Continuous by discrete for tick mark.
soft(c_d_tick) :- is_c_d, not no_overlap, mark(tick).

% @constraint Continuous by discrete for point mark with no overlap.
soft(c_d_no_overlap_point) :- is_c_d, no_overlap, mark(point).

% @constraint Continuous by discrete for bar mark with no overlap.
soft(c_d_no_overlap_bar) :- is_c_d, no_overlap, mark(bar).

% @constraint Continuous by discrete for line mark with no overlap.
soft(c_d_no_overlap_line) :- is_c_d, no_overlap, mark(line).

% @constraint Continuous by discrete for area mark with no overlap.
soft(c_d_no_overlap_area) :- is_c_d, no_overlap, mark(area).

% @constraint Continuous by discrete for text mark with no overlap.
soft(c_d_no_overlap_text) :- is_c_d, no_overlap, mark(text).

% @constraint Continuous by discrete for tick mark with no overlap.
soft(c_d_no_overlap_tick) :- is_c_d, no_overlap, mark(tick).

% @constraint Discrete by discrete for point mark.
soft(d_d_point) :- is_d_d, mark(point).

% @constraint Discrete by discrete for point mark.
soft(d_d_text) :- is_d_d, mark(text).

% @constraint Discrete by discrete for point mark.
soft(d_d_rect) :- is_d_d, mark(rect).

% === Channel rankings à la APT ===

% @constraint Continuous on x channel.
soft(continuous_x,E) :- channel(E,x), continuous(E).

% @constraint Continuous on y channel.
soft(continuous_y,E) :- channel(E,y), continuous(E).

% @constraint Continuous on color channel.
soft(continuous_color,E) :- channel(E,color), continuous(E).

% @constraint Continuous on size channel.
soft(continuous_size,E) :- channel(E,size), continuous(E).

% @constraint Continuous on text channel.
soft(continuous_text,E) :- channel(E,text), continuous(E).

% @constraint Ordered on x channel.
soft(ordered_x,E) :- channel(E,x), discrete(E), not type(E,nominal).

% @constraint Ordered on y channel.
soft(ordered_y,E) :- channel(E,y), discrete(E), not type(E,nominal).

% @constraint Ordered on color channel.
soft(ordered_color,E) :- channel(E,color), discrete(E), not type(E,nominal).

% @constraint Ordered on size channel.
soft(ordered_size,E) :- channel(E,size), discrete(E), not type(E,nominal).

% @constraint Ordered on text channel.
soft(ordered_text,E) :- channel(E,text), discrete(E), not type(E,nominal).

% @constraint Ordered on row channel.
soft(ordered_row,E) :- channel(E,row), discrete(E), not type(E,nominal).

% @constraint Ordered on column channel.
soft(ordered_column,E) :- channel(E,column), discrete(E), not type(E,nominal).

% @constraint Nominal on x channel.
soft(nominal_x,E) :- channel(E,x), type(E,nominal).

% @constraint Nominal on y channel.
soft(nominal_y,E) :- channel(E,y), type(E,nominal).

% @constraint Nominal on color channel.
soft(nominal_color,E) :- channel(E,color), type(E,nominal).

% @constraint Nominal on shape channel.
soft(nominal_shape,E) :- channel(E,shape), type(E,nominal).

% @constraint Nominal on text channel.
soft(nominal_text,E) :- channel(E,text), type(E,nominal).

% @constraint Nominal on row channel.
soft(nominal_row,E) :- channel(E,row), type(E,nominal).

% @constraint Nominal on column channel.
soft(nominal_column,E) :- channel(E,column), type(E,nominal).

% @constraint Nominal on detail channel.
soft(nominal_detail,E) :- channel(E,detail), type(E,nominal).

% @constraint Interesting on x channel.
soft(interesting_x,E) :- channel(E,x), enc_interesting(E).

% @constraint Interesting on y channel.
soft(interesting_y,E) :- channel(E,y), enc_interesting(E).

% @constraint Interesting on color channel.
soft(interesting_color,E) :- channel(E,color), enc_interesting(E).

% @constraint Interesting on size channel.
soft(interesting_size,E) :- channel(E,size), enc_interesting(E).

% @constraint Interesting on shape channel.
soft(interesting_shape,E) :- channel(E,shape), enc_interesting(E).

% @constraint Interesting on text channel.
soft(interesting_text,E) :- channel(E,text), enc_interesting(E).

% @constraint Interesting on row channel.
soft(interesting_row,E) :- channel(E,row), enc_interesting(E).

% @constraint Interesting on column channel.
soft(interesting_column,E) :- channel(E,column), enc_interesting(E).

% @constraint Interesting on detail channel.
soft(interesting_detail,E) :- channel(E,detail), enc_interesting(E).

% === Aggregations ===

% @constraint Count as aggregate op.
soft(aggregate_count,E) :- aggregate(E,count).

% @constraint Sum as aggregate op.
soft(aggregate_sum,E) :- aggregate(E,sum).

% @constraint Mean as aggregate op.
soft(aggregate_mean,E) :- aggregate(E,mean).

% @constraint Median as aggregate op.
soft(aggregate_median,E) :- aggregate(E,median).

% @constraint Min as aggregate op.
soft(aggregate_min,E) :- aggregate(E,min).

% @constraint Max as aggregate op.
soft(aggregate_max,E) :- aggregate(E,max).

% @constraint Standard Deviation as aggregate op.
soft(aggregate_stdev,E) :- aggregate(E,stdev).

% === Stack ===

% @constraint Zero base for stack op.
soft(stack_zero) :- stack(zero).

% @constraint Normalize between groupbys as stack op.
soft(stack_normalize) :- stack(normalize).

% === Task - marktype correlations ===

% @constraint Point mark for value tasks.
soft(value_point) :- task(value), mark(point).

% @constraint Bar mark for value tasks.
soft(value_bar) :- task(value), mark(bar).

% @constraint Line mark for value tasks.
soft(value_line) :- task(value), mark(line).

% @constraint Area mark for value tasks.
soft(value_area) :- task(value), mark(area).

% @constraint Text mark for value tasks.
soft(value_text) :- task(value), mark(text).

% @constraint Tick mark for value tasks.
soft(value_tick) :- task(value), mark(tick).
% @end

% @constraint Rect mark for value tasks.
soft(value_rect) :- task(value), mark(rect).

% @constraint Point mark for summary tasks.
soft(summary_point) :- task(summary), mark(point).

% @constraint Bar mark for summary tasks.
soft(summary_bar) :- task(summary), mark(bar).

% @constraint Line mark for summary tasks.
soft(summary_line) :- task(summary), mark(line).

% @constraint Area mark for summary tasks.
soft(summary_area) :- task(summary), mark(area).

% @constraint Text mark for summary tasks.
soft(summary_text) :- task(summary), mark(text).

% @constraint Tick mark for summary tasks.
soft(summary_tick) :- task(summary), mark(tick).

% @constraint Rect mark for summary tasks.
soft(summary_rect) :- task(summary), mark(rect).

% === Task - channel correlations ===

% @constraint Continuous x for value tasks.
soft(value_continuous_x,E) :- task(value), channel(E,x), continuous(E), enc_interesting(E).

% @constraint Continuous y for value tasks.
soft(value_continuous_y,E) :- task(value), channel(E,y), continuous(E), enc_interesting(E).

% @constraint Continuous color for value tasks.
soft(value_continuous_color,E) :- task(value), channel(E,color), continuous(E), enc_interesting(E).

% @constraint Continuous size for value tasks.
soft(value_continuous_size,E) :- task(value), channel(E,size), continuous(E), enc_interesting(E).

% @constraint Continuous text for value tasks.
soft(value_continuous_text,E) :- task(value), channel(E,text), continuous(E), enc_interesting(E).

% @constraint Discrete x for value tasks.
soft(value_discrete_x,E) :- task(value), channel(E,x), discrete(E), enc_interesting(E).

% @constraint Discrete y for value tasks.
soft(value_discrete_y,E) :- task(value), channel(E,y), discrete(E), enc_interesting(E).

% @constraint Discrete color for value tasks.
soft(value_discrete_color,E) :- task(value), channel(E,color), discrete(E), enc_interesting(E).

% @constraint Discrete shape for value tasks.
soft(value_discrete_shape,E) :- task(value), channel(E,shape), discrete(E), enc_interesting(E).

% @constraint Discrete size for value tasks.
soft(value_discrete_size,E) :- task(value), channel(E,size), discrete(E), enc_interesting(E).

% @constraint Discrete text for value tasks.
soft(value_discrete_text,E) :- task(value), channel(E,text), discrete(E), enc_interesting(E).

% @constraint Discrete row for value tasks.
soft(value_discrete_row,E) :- task(value), channel(E,row), discrete(E), enc_interesting(E).

% @constraint Discrete column for value tasks.
soft(value_discrete_column,E) :- task(value), channel(E,column), discrete(E), enc_interesting(E).

% @constraint Continuous x for summary tasks.
soft(summary_continuous_x,E) :- task(summary), channel(E,x), continuous(E), enc_interesting(E).

% @constraint Continuous y for summary tasks.
soft(summary_continuous_y,E) :- task(summary), channel(E,y), continuous(E), enc_interesting(E).

% @constraint Continuous color for summary tasks.
soft(summary_continuous_color,E) :- task(summary), channel(E,color), continuous(E), enc_interesting(E).

% @constraint Continuous size for summary tasks.
soft(summary_continuous_size,E) :- task(summary), channel(E,size), continuous(E), enc_interesting(E).

% @constraint Continuous text for summary tasks.
soft(summary_continuous_text,E) :- task(summary), channel(E,text), continuous(E), enc_interesting(E).

% @constraint Discrete x for summary tasks.
soft(summary_discrete_x,E) :- task(summary), channel(E,x), discrete(E), enc_interesting(E).

% @constraint Discrete y for summary tasks.
soft(summary_discrete_y,E) :- task(summary), channel(E,y), discrete(E), enc_interesting(E).

% @constraint Discrete color for summary tasks.
soft(summary_discrete_color,E) :- task(summary), channel(E,color), discrete(E), enc_interesting(E).

% @constraint Discrete shape for summary tasks.
soft(summary_discrete_shape,E) :- task(summary), channel(E,shape), discrete(E), enc_interesting(E).

% @constraint Discrete size for summary tasks.
soft(summary_discrete_size,E) :- task(summary), channel(E,size), discrete(E), enc_interesting(E).

% @constraint Discrete text for summary tasks.
soft(summary_discrete_text,E) :- task(summary), channel(E,text), discrete(E), enc_interesting(E).

% @constraint Discrete row for summary tasks.
soft(summary_discrete_row,E) :- task(summary), channel(E,row), discrete(E), enc_interesting(E).

% @constraint Discrete column for summary tasks.
soft(summary_discrete_column,E) :- task(summary), channel(E,column), discrete(E), enc_interesting(E).

`;
    const WEIGHTS = `% Weights as constants

#const type_q_weight = 0.
#const type_o_weight = 1.
#const type_n_weight = 2.
#const aggregate_weight = 1.
#const bin_weight = 2.
#const bin_high_weight = 10.
#const bin_low_weight = 6.
#const encoding_weight = 0.
#const encoding_field_weight = 6.
#const same_field_2_weight = 8.
#const same_field_gte3_weight = 16.
#const count_twice_weight = 50.
#const shape_cardinality_weight = 5.
#const number_nominal_weight = 10.
#const string_non_nominal_weight = 2.
#const bin_cardinality_weight = 5.
#const quant_bin_weight = 1.
#const agg_dim_weight = 2.
#const only_discrete_weight = 30.
#const multiple_non_pos_weight = 3.
#const non_positional_pref_weight = 10.
#const aggregate_group_by_raw_weight = 3.
#const x_y_raw_weight = 1.
#const log_weight = 1.
#const zero_weight = 1.
#const zero_size_weight = 3.
#const zero_positional_weight = 1.
#const zero_skew_weight = 5.
#const includes_zero_weight = 10.

#const only_x_weight = 1.
#const orientation_binned_weight = 1.
#const high_cardinality_ordinal_weight = 10.
#const high_cardinality_nominal_weight = 10.
#const high_cardinality_nominal_color_weight = 10.
#const horizontal_scrolling_weight = 20.
#const temporal_date_weight = 1.
#const quantitative_numbers_weight = 2.
#const position_entropy_weight = 2.
#const high_cardinality_size_weight = 1.
#const value_agg_weight = 1.
#const facet_summary_weight = 0.
#const x_row_weight = 1.
#const y_row_weight = 1.
#const x_column_weight = 1.
#const y_column_weight = 1.
#const color_entropy_high_weight = 0.
#const color_entropy_low_weight = 0.
#const size_entropy_high_weight = 0.
#const size_entropy_low_weight = 0.

#const c_d_column_weight = 5.
#const temporal_y_weight = 1.
#const d_d_overlap_weight = 20.

#const c_c_point_weight = 0.
#const c_c_line_weight = 20.
#const c_c_area_weight = 20.
#const c_c_text_weight = 2.
#const c_c_tick_weight = 5.

#const c_d_point_weight = 10.
#const c_d_bar_weight = 20.
#const c_d_line_weight = 20.
#const c_d_area_weight = 20.
#const c_d_text_weight = 50.
#const c_d_tick_weight = 0.

#const c_d_no_overlap_point_weight = 20.
#const c_d_no_overlap_bar_weight = 0.
#const c_d_no_overlap_line_weight = 20.
#const c_d_no_overlap_area_weight = 20.
#const c_d_no_overlap_text_weight = 30.
#const c_d_no_overlap_tick_weight = 25.

#const d_d_point_weight = 0.
#const d_d_text_weight = 1.
#const d_d_rect_weight = 0.

#const continuous_x_weight = 0.
#const continuous_y_weight = 0.
#const continuous_color_weight = 10.
#const continuous_size_weight = 1.
#const continuous_text_weight = 20.

#const ordered_x_weight = 1.
#const ordered_y_weight = 0.
#const ordered_color_weight = 8.
#const ordered_size_weight = 10.
#const ordered_text_weight = 32.
#const ordered_row_weight = 10.
#const ordered_column_weight = 10.

#const nominal_x_weight = 3.
#const nominal_y_weight = 0.
#const nominal_color_weight = 10.
#const nominal_shape_weight = 11.
#const nominal_text_weight = 12.
#const nominal_row_weight = 7.
#const nominal_column_weight = 10.
#const nominal_detail_weight = 20.

#const interesting_x_weight = 0.
#const interesting_y_weight = 1.
#const interesting_color_weight = 2.
#const interesting_size_weight = 2.
#const interesting_shape_weight = 3.
#const interesting_text_weight = 6.
#const interesting_row_weight = 6.
#const interesting_column_weight = 7.
#const interesting_detail_weight = 20.

#const aggregate_count_weight = 0.
#const aggregate_sum_weight = 2.
#const aggregate_mean_weight = 1.
#const aggregate_median_weight = 3.
#const aggregate_min_weight = 4.
#const aggregate_max_weight = 4.
#const aggregate_stdev_weight = 5.

#const value_point_weight = 0.
#const value_bar_weight = 0.
#const value_line_weight = 0.
#const value_area_weight = 0.
#const value_text_weight = 0.
#const value_tick_weight = 0.
#const value_rect_weight = 0.
#const summary_point_weight = 0.
#const summary_bar_weight = 0.
#const summary_line_weight = 0.
#const summary_area_weight = 0.
#const summary_text_weight = 0.
#const summary_tick_weight = 0.
#const summary_rect_weight = 0.

#const value_continuous_x_weight = 0.
#const value_continuous_y_weight = 0.
#const value_continuous_color_weight = 0.
#const value_continuous_size_weight = 0.
#const value_continuous_text_weight = 0.
#const value_discrete_x_weight = 0.
#const value_discrete_y_weight = 0.
#const value_discrete_color_weight = 0.
#const value_discrete_shape_weight = 0.
#const value_discrete_size_weight = 0.
#const value_discrete_text_weight = 0.
#const value_discrete_row_weight = 0.
#const value_discrete_column_weight = 0.
#const summary_continuous_x_weight = 0.
#const summary_continuous_y_weight = 0.
#const summary_continuous_color_weight = 0.
#const summary_continuous_size_weight = 0.
#const summary_continuous_text_weight = 0.
#const summary_discrete_x_weight = 0.
#const summary_discrete_y_weight = 0.
#const summary_discrete_color_weight = 0.
#const summary_discrete_shape_weight = 0.
#const summary_discrete_size_weight = 0.
#const summary_discrete_text_weight = 0.
#const summary_discrete_row_weight = 0.
#const summary_discrete_column_weight = 0.

#const stack_zero_weight = 0.
#const stack_normalize_weight = 1.

`;
    const ASSIGN_WEIGHTS = `%% GENERATED FILE. DO NOT EDIT.

soft_weight(type_q,type_q_weight).
soft_weight(type_o,type_o_weight).
soft_weight(type_n,type_n_weight).
soft_weight(aggregate,aggregate_weight).
soft_weight(bin,bin_weight).
soft_weight(bin_high,bin_high_weight).
soft_weight(bin_low,bin_low_weight).
soft_weight(encoding,encoding_weight).
soft_weight(encoding_field,encoding_field_weight).
soft_weight(same_field_2,same_field_2_weight).
soft_weight(same_field_gte3,same_field_gte3_weight).
soft_weight(count_twice,count_twice_weight).
soft_weight(shape_cardinality,shape_cardinality_weight).
soft_weight(number_nominal,number_nominal_weight).
soft_weight(string_non_nominal,string_non_nominal_weight).
soft_weight(bin_cardinality,bin_cardinality_weight).
soft_weight(quant_bin,quant_bin_weight).
soft_weight(agg_dim,agg_dim_weight).
soft_weight(only_discrete,only_discrete_weight).
soft_weight(multiple_non_pos,multiple_non_pos_weight).
soft_weight(non_positional_pref,non_positional_pref_weight).
soft_weight(aggregate_group_by_raw,aggregate_group_by_raw_weight).
soft_weight(x_y_raw,x_y_raw_weight).
soft_weight(log,log_weight).
soft_weight(zero,zero_weight).
soft_weight(zero_size,zero_size_weight).
soft_weight(zero_positional,zero_positional_weight).
soft_weight(zero_skew,zero_skew_weight).
soft_weight(includes_zero,includes_zero_weight).
soft_weight(only_x,only_x_weight).
soft_weight(orientation_binned,orientation_binned_weight).
soft_weight(high_cardinality_ordinal,high_cardinality_ordinal_weight).
soft_weight(high_cardinality_nominal,high_cardinality_nominal_weight).
soft_weight(high_cardinality_nominal_color,high_cardinality_nominal_color_weight).
soft_weight(horizontal_scrolling,horizontal_scrolling_weight).
soft_weight(temporal_date,temporal_date_weight).
soft_weight(quantitative_numbers,quantitative_numbers_weight).
soft_weight(position_entropy,position_entropy_weight).
soft_weight(high_cardinality_size,high_cardinality_size_weight).
soft_weight(value_agg,value_agg_weight).
soft_weight(facet_summary,facet_summary_weight).
soft_weight(x_row,x_row_weight).
soft_weight(y_row,y_row_weight).
soft_weight(x_column,x_column_weight).
soft_weight(y_column,y_column_weight).
soft_weight(color_entropy_high,color_entropy_high_weight).
soft_weight(color_entropy_low,color_entropy_low_weight).
soft_weight(size_entropy_high,size_entropy_high_weight).
soft_weight(size_entropy_low,size_entropy_low_weight).
soft_weight(c_d_column,c_d_column_weight).
soft_weight(temporal_y,temporal_y_weight).
soft_weight(d_d_overlap,d_d_overlap_weight).
soft_weight(c_c_point,c_c_point_weight).
soft_weight(c_c_line,c_c_line_weight).
soft_weight(c_c_area,c_c_area_weight).
soft_weight(c_c_text,c_c_text_weight).
soft_weight(c_c_tick,c_c_tick_weight).
soft_weight(c_d_point,c_d_point_weight).
soft_weight(c_d_bar,c_d_bar_weight).
soft_weight(c_d_line,c_d_line_weight).
soft_weight(c_d_area,c_d_area_weight).
soft_weight(c_d_text,c_d_text_weight).
soft_weight(c_d_tick,c_d_tick_weight).
soft_weight(c_d_no_overlap_point,c_d_no_overlap_point_weight).
soft_weight(c_d_no_overlap_bar,c_d_no_overlap_bar_weight).
soft_weight(c_d_no_overlap_line,c_d_no_overlap_line_weight).
soft_weight(c_d_no_overlap_area,c_d_no_overlap_area_weight).
soft_weight(c_d_no_overlap_text,c_d_no_overlap_text_weight).
soft_weight(c_d_no_overlap_tick,c_d_no_overlap_tick_weight).
soft_weight(d_d_point,d_d_point_weight).
soft_weight(d_d_text,d_d_text_weight).
soft_weight(d_d_rect,d_d_rect_weight).
soft_weight(continuous_x,continuous_x_weight).
soft_weight(continuous_y,continuous_y_weight).
soft_weight(continuous_color,continuous_color_weight).
soft_weight(continuous_size,continuous_size_weight).
soft_weight(continuous_text,continuous_text_weight).
soft_weight(ordered_x,ordered_x_weight).
soft_weight(ordered_y,ordered_y_weight).
soft_weight(ordered_color,ordered_color_weight).
soft_weight(ordered_size,ordered_size_weight).
soft_weight(ordered_text,ordered_text_weight).
soft_weight(ordered_row,ordered_row_weight).
soft_weight(ordered_column,ordered_column_weight).
soft_weight(nominal_x,nominal_x_weight).
soft_weight(nominal_y,nominal_y_weight).
soft_weight(nominal_color,nominal_color_weight).
soft_weight(nominal_shape,nominal_shape_weight).
soft_weight(nominal_text,nominal_text_weight).
soft_weight(nominal_row,nominal_row_weight).
soft_weight(nominal_column,nominal_column_weight).
soft_weight(nominal_detail,nominal_detail_weight).
soft_weight(interesting_x,interesting_x_weight).
soft_weight(interesting_y,interesting_y_weight).
soft_weight(interesting_color,interesting_color_weight).
soft_weight(interesting_size,interesting_size_weight).
soft_weight(interesting_shape,interesting_shape_weight).
soft_weight(interesting_text,interesting_text_weight).
soft_weight(interesting_row,interesting_row_weight).
soft_weight(interesting_column,interesting_column_weight).
soft_weight(interesting_detail,interesting_detail_weight).
soft_weight(aggregate_count,aggregate_count_weight).
soft_weight(aggregate_sum,aggregate_sum_weight).
soft_weight(aggregate_mean,aggregate_mean_weight).
soft_weight(aggregate_median,aggregate_median_weight).
soft_weight(aggregate_min,aggregate_min_weight).
soft_weight(aggregate_max,aggregate_max_weight).
soft_weight(aggregate_stdev,aggregate_stdev_weight).
soft_weight(value_point,value_point_weight).
soft_weight(value_bar,value_bar_weight).
soft_weight(value_line,value_line_weight).
soft_weight(value_area,value_area_weight).
soft_weight(value_text,value_text_weight).
soft_weight(value_tick,value_tick_weight).
soft_weight(value_rect,value_rect_weight).
soft_weight(summary_point,summary_point_weight).
soft_weight(summary_bar,summary_bar_weight).
soft_weight(summary_line,summary_line_weight).
soft_weight(summary_area,summary_area_weight).
soft_weight(summary_text,summary_text_weight).
soft_weight(summary_tick,summary_tick_weight).
soft_weight(summary_rect,summary_rect_weight).
soft_weight(value_continuous_x,value_continuous_x_weight).
soft_weight(value_continuous_y,value_continuous_y_weight).
soft_weight(value_continuous_color,value_continuous_color_weight).
soft_weight(value_continuous_size,value_continuous_size_weight).
soft_weight(value_continuous_text,value_continuous_text_weight).
soft_weight(value_discrete_x,value_discrete_x_weight).
soft_weight(value_discrete_y,value_discrete_y_weight).
soft_weight(value_discrete_color,value_discrete_color_weight).
soft_weight(value_discrete_shape,value_discrete_shape_weight).
soft_weight(value_discrete_size,value_discrete_size_weight).
soft_weight(value_discrete_text,value_discrete_text_weight).
soft_weight(value_discrete_row,value_discrete_row_weight).
soft_weight(value_discrete_column,value_discrete_column_weight).
soft_weight(summary_continuous_x,summary_continuous_x_weight).
soft_weight(summary_continuous_y,summary_continuous_y_weight).
soft_weight(summary_continuous_color,summary_continuous_color_weight).
soft_weight(summary_continuous_size,summary_continuous_size_weight).
soft_weight(summary_continuous_text,summary_continuous_text_weight).
soft_weight(summary_discrete_x,summary_discrete_x_weight).
soft_weight(summary_discrete_y,summary_discrete_y_weight).
soft_weight(summary_discrete_color,summary_discrete_color_weight).
soft_weight(summary_discrete_shape,summary_discrete_shape_weight).
soft_weight(summary_discrete_size,summary_discrete_size_weight).
soft_weight(summary_discrete_text,summary_discrete_text_weight).
soft_weight(summary_discrete_row,summary_discrete_row_weight).
soft_weight(summary_discrete_column,summary_discrete_column_weight).
soft_weight(stack_zero,stack_zero_weight).
soft_weight(stack_normalize,stack_normalize_weight).

`;
    const OPTIMIZE = `% Minimize the feature weight

#minimize { W,F,Q: soft_weight(F,W), soft(F,Q); #inf,F,Q: soft(F,Q), not soft_weight(F,_); #inf,F: hard(F); #inf,F,Q: hard(F,Q); #inf,F,Q1,Q2: hard(F,Q1,Q2) }.

`;
    const OUTPUT = `% ====== Output ======

#show data/1.

#show mark/1.

#show type/2.
#show channel/2.
#show field/2.
#show aggregate/2.
#show bin/2.
#show stack/2.

#show log/1.
#show zero/1.

#show soft/2.

`;

    var constraints = /*#__PURE__*/Object.freeze({
        TOPK_LUA: TOPK_LUA,
        DEFINE: DEFINE,
        GENERATE: GENERATE,
        HARD: HARD,
        HARD_INTEGRITY: HARD_INTEGRITY,
        SOFT: SOFT,
        WEIGHTS: WEIGHTS,
        ASSIGN_WEIGHTS: ASSIGN_WEIGHTS,
        OPTIMIZE: OPTIMIZE,
        OUTPUT: OUTPUT
    });

    function constraints2json(constraintsAsp, weightsAsp) {
        const constraints = constraintsAsp.match(CONSTRAINT_MATCH);
        if (!constraints) {
            throw Error('invalid constraints');
        }
        const result = constraints.map((s) => {
            const doc = getDoc(s);
            const asp = getAsp(s);
            return {
                ...doc,
                ...asp,
            };
        });
        if (weightsAsp) {
            const weights = weightsAsp.match(WEIGHTS_MATCH);
            const weightMap = getWeightMap(weights);
            if (!weights) {
                throw Error('invalid weights');
            }
            for (const constraint of result) {
                const name = constraint.name;
                constraint.weight = weightMap[name];
            }
        }
        return result;
    }
    function getDoc(s) {
        const docMatch = s.match(DOC_MATCH);
        if (docMatch) {
            const docString = docMatch[0];
            const descriptionParts = DESCRIPTION_EXTRACT.exec(docString);
            if (descriptionParts) {
                return {
                    description: descriptionParts[1],
                };
            }
        }
        return null;
    }
    function getAsp(s) {
        const aspMatch = s.match(ASP_MATCH);
        if (aspMatch) {
            const asp = aspMatch.join('\n');
            const typeExtract = TYPE_EXTRACT.exec(asp);
            if (!typeExtract) {
                throw Error(`invalid asp: ${asp}`);
            }
            const type = typeExtract[1];
            const nameExtract = NAME_EXTRACT.exec(asp);
            if (!nameExtract) {
                throw Error(`invalid asp: ${asp}`);
            }
            const name = nameExtract[1];
            return {
                type,
                name,
                asp,
            };
        }
        return null;
    }
    function getWeightMap(weights) {
        const map = {};
        for (const weight of weights) {
            const nameExtract = WEIGHT_NAME_EXTRACT.exec(weight);
            if (!nameExtract) {
                throw Error(`invalid weight: ${weight}`);
            }
            const name = nameExtract[1];
            const valueExtract = WEIGHT_VALUE_EXTRACT.exec(weight);
            if (!valueExtract) {
                throw Error(`invalid weight: ${weight}`);
            }
            const value = +valueExtract[1];
            map[name] = value;
        }
        return map;
    }
    const CONSTRAINT_MATCH = /%\s*@constraint(?:(.+)\n)+/g;
    const DOC_MATCH = /(%.*\n)+/g;
    const DESCRIPTION_EXTRACT = /@constraint\s+(.*)/;
    const ASP_MATCH = /^[^%].*/gm;
    const TYPE_EXTRACT = /(\w+)\(/;
    const NAME_EXTRACT = /\((\w+),?.*?\)/;
    const WEIGHTS_MATCH = /#const.*/g;
    const WEIGHT_NAME_EXTRACT = /#const\s+(\w+?)_weight/;
    const WEIGHT_VALUE_EXTRACT = /=\s*(\d+)/;

    const HOLE = '?';
    function cql2asp(spec) {
        const mark = subst_if_hole(spec.mark);
        const facts = [];
        if (mark) {
            facts.push(`mark(${spec.mark}).`);
        }
        if ('data' in spec && 'url' in spec.data) {
            facts.push(`data("${spec.data.url}").`);
        }
        for (let i = 0; i < spec.encodings.length; i++) {
            const enc = spec.encodings[i];
            const eid = `e${i}`;
            facts.push(`encoding(${eid}).`);
            let encFieldType = null;
            let encZero = null;
            let encBinned = null;
            for (const field of Object.keys(enc)) {
                const fieldContent = subst_if_hole(enc[field]);
                if (!fieldContent) {
                    continue;
                }
                if (!remove_if_star(fieldContent)) {
                    continue;
                }
                if (field === 'type') {
                    encFieldType = fieldContent;
                }
                if (field === 'bin') {
                    encBinned = fieldContent;
                }
                if (field === 'scale') {
                    // translate two boolean fields
                    if ('zero' in fieldContent) {
                        encZero = fieldContent.zero;
                        if (fieldContent.zero) {
                            facts.push(`zero(${eid}).`);
                        }
                        else {
                            facts.push(`:- zero(${eid}).`);
                        }
                    }
                    if ('log' in fieldContent) {
                        if (fieldContent.log) {
                            facts.push(`log(${eid}).`);
                        }
                        else {
                            facts.push(`:-log(${eid}).`);
                        }
                    }
                }
                else if (field === 'bin') {
                    if (fieldContent.maxbins) {
                        facts.push(`${field}(${eid},${fieldContent.maxbins}).`);
                    }
                    else if (fieldContent) {
                        facts.push(`:- not bin(${eid},_).`);
                    }
                    else {
                        facts.push(`:- bin(${eid},_).`);
                    }
                }
                else if (field === 'field') {
                    // fields can have spaces and start with capital letters
                    facts.push(`${field}(${eid},"${fieldContent}").`);
                }
                else {
                    // translate normal fields
                    if (field !== 'bin') {
                        facts.push(`${field}(${eid},${fieldContent}).`);
                    }
                }
            }
            if (encFieldType === 'quantitative' && encZero === null && encBinned === null) {
                facts.push(`zero(${eid}).`);
            }
        }
        return facts;
    }
    function subst_if_hole(v) {
        return v !== HOLE ? v : null;
    }
    function remove_if_star(v) {
        return v !== '*' ? v : null;
    }

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var util = createCommonjsModule(function (module) {
    var u = module.exports;

    // utility functions

    var FNAME = '__name__';

    u.namedfunc = function(name, f) { return (f[FNAME] = name, f); };

    u.name = function(f) { return f==null ? null : f[FNAME]; };

    u.identity = function(x) { return x; };

    u.true = u.namedfunc('true', function() { return true; });

    u.false = u.namedfunc('false', function() { return false; });

    u.duplicate = function(obj) {
      return JSON.parse(JSON.stringify(obj));
    };

    u.equal = function(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    };

    u.extend = function(obj) {
      for (var x, name, i=1, len=arguments.length; i<len; ++i) {
        x = arguments[i];
        for (name in x) { obj[name] = x[name]; }
      }
      return obj;
    };

    u.length = function(x) {
      return x != null && x.length != null ? x.length : null;
    };

    u.keys = function(x) {
      var keys = [], k;
      for (k in x) keys.push(k);
      return keys;
    };

    u.vals = function(x) {
      var vals = [], k;
      for (k in x) vals.push(x[k]);
      return vals;
    };

    u.toMap = function(list, f) {
      return (f = u.$(f)) ?
        list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :
        list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});
    };

    u.keystr = function(values) {
      // use to ensure consistent key generation across modules
      var n = values.length;
      if (!n) return '';
      for (var s=String(values[0]), i=1; i<n; ++i) {
        s += '|' + String(values[i]);
      }
      return s;
    };

    // type checking functions

    var toString = Object.prototype.toString;

    u.isObject = function(obj) {
      return obj === Object(obj);
    };

    u.isFunction = function(obj) {
      return toString.call(obj) === '[object Function]';
    };

    u.isString = function(obj) {
      return typeof value === 'string' || toString.call(obj) === '[object String]';
    };

    u.isArray = Array.isArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };

    u.isNumber = function(obj) {
      return typeof obj === 'number' || toString.call(obj) === '[object Number]';
    };

    u.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    u.isDate = function(obj) {
      return toString.call(obj) === '[object Date]';
    };

    u.isValid = function(obj) {
      return obj != null && obj === obj;
    };

    u.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;

    // type coercion functions

    u.number = function(s) {
      return s == null || s === '' ? null : +s;
    };

    u.boolean = function(s) {
      return s == null || s === '' ? null : s==='false' ? false : !!s;
    };

    // parse a date with optional d3.time-format format
    u.date = function(s, format) {
      var d = format ? format : Date;
      return s == null || s === '' ? null : d.parse(s);
    };

    u.array = function(x) {
      return x != null ? (u.isArray(x) ? x : [x]) : [];
    };

    u.str = function(x) {
      return u.isArray(x) ? '[' + x.map(u.str) + ']'
        : u.isObject(x) || u.isString(x) ?
          // Output valid JSON and JS source strings.
          // See http://timelessrepo.com/json-isnt-a-javascript-subset
          JSON.stringify(x).replace('\u2028','\\u2028').replace('\u2029', '\\u2029')
        : x;
    };

    // data access functions

    var field_re = /\[(.*?)\]|[^.\[]+/g;

    u.field = function(f) {
      return String(f).match(field_re).map(function(d) {
        return d[0] !== '[' ? d :
          d[1] !== "'" && d[1] !== '"' ? d.slice(1, -1) :
          d.slice(2, -2).replace(/\\(["'])/g, '$1');
      });
    };

    u.accessor = function(f) {
      /* jshint evil: true */
      return f==null || u.isFunction(f) ? f :
        u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));
    };

    // short-cut for accessor
    u.$ = u.accessor;

    u.mutator = function(f) {
      var s;
      return u.isString(f) && (s=u.field(f)).length > 1 ?
        function(x, v) {
          for (var i=0; i<s.length-1; ++i) x = x[s[i]];
          x[s[i]] = v;
        } :
        function(x, v) { x[f] = v; };
    };


    u.$func = function(name, op) {
      return function(f) {
        f = u.$(f) || u.identity;
        var n = name + (u.name(f) ? '_'+u.name(f) : '');
        return u.namedfunc(n, function(d) { return op(f(d)); });
      };
    };

    u.$valid  = u.$func('valid', u.isValid);
    u.$length = u.$func('length', u.length);

    u.$in = function(f, values) {
      f = u.$(f);
      var map = u.isArray(values) ? u.toMap(values) : values;
      return function(d) { return !!map[f(d)]; };
    };

    // comparison / sorting functions

    u.comparator = function(sort) {
      var sign = [];
      if (sort === undefined) sort = [];
      sort = u.array(sort).map(function(f) {
        var s = 1;
        if      (f[0] === '-') { s = -1; f = f.slice(1); }
        else if (f[0] === '+') { s = +1; f = f.slice(1); }
        sign.push(s);
        return u.accessor(f);
      });
      return function(a, b) {
        var i, n, f, c;
        for (i=0, n=sort.length; i<n; ++i) {
          f = sort[i];
          c = u.cmp(f(a), f(b));
          if (c) return c * sign[i];
        }
        return 0;
      };
    };

    u.cmp = function(a, b) {
      return (a < b || a == null) && b != null ? -1 :
        (a > b || b == null) && a != null ? 1 :
        ((b = b instanceof Date ? +b : b),
         (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :
        b !== b && a === a ? 1 : 0;
    };

    u.numcmp = function(a, b) { return a - b; };

    u.stablesort = function(array, sortBy, keyFn) {
      var indices = array.reduce(function(idx, v, i) {
        return (idx[keyFn(v)] = i, idx);
      }, {});

      array.sort(function(a, b) {
        var sa = sortBy(a),
            sb = sortBy(b);
        return sa < sb ? -1 : sa > sb ? 1
             : (indices[keyFn(a)] - indices[keyFn(b)]);
      });

      return array;
    };

    // permutes an array using a Knuth shuffle
    u.permute = function(a) {
      var m = a.length,
          swap,
          i;

      while (m) {
        i = Math.floor(Math.random() * m--);
        swap = a[m];
        a[m] = a[i];
        a[i] = swap;
      }
    };

    // string functions

    u.pad = function(s, length, pos, padchar) {
      padchar = padchar || " ";
      var d = length - s.length;
      if (d <= 0) return s;
      switch (pos) {
        case 'left':
          return strrep(d, padchar) + s;
        case 'middle':
        case 'center':
          return strrep(Math.floor(d/2), padchar) +
             s + strrep(Math.ceil(d/2), padchar);
        default:
          return s + strrep(d, padchar);
      }
    };

    function strrep(n, str) {
      var s = "", i;
      for (i=0; i<n; ++i) s += str;
      return s;
    }

    u.truncate = function(s, length, pos, word, ellipsis) {
      var len = s.length;
      if (len <= length) return s;
      ellipsis = ellipsis !== undefined ? String(ellipsis) : '\u2026';
      var l = Math.max(0, length - ellipsis.length);

      switch (pos) {
        case 'left':
          return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));
        case 'middle':
        case 'center':
          var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);
          return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +
            ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));
        default:
          return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;
      }
    };

    function truncateOnWord(s, len, rev) {
      var cnt = 0, tok = s.split(truncate_word_re);
      if (rev) {
        s = (tok = tok.reverse())
          .filter(function(w) { cnt += w.length; return cnt <= len; })
          .reverse();
      } else {
        s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });
      }
      return s.length ? s.join('').trim() : tok[0].slice(0, len);
    }

    var truncate_word_re = /([\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF])/;
    });

    var TYPES = '__types__';

    var PARSERS = {
      boolean: util.boolean,
      integer: util.number,
      number:  util.number,
      date:    util.date,
      string:  function(x) { return x == null || x === '' ? null : x + ''; }
    };

    var TESTS = {
      boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },
      integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },
      number: function(x) { return !isNaN(+x) && !util.isDate(x); },
      date: function(x) { return !isNaN(Date.parse(x)); }
    };

    function annotation(data, types) {
      if (!types) return data && data[TYPES] || null;
      data[TYPES] = types;
    }

    function fieldNames(datum) {
      return util.keys(datum);
    }

    function bracket(fieldName) {
      return '[' + fieldName + ']';
    }

    function type(values, f) {
      values = util.array(values);
      f = util.$(f);
      var v, i, n;

      // if data array has type annotations, use them
      if (values[TYPES]) {
        v = f(values[TYPES]);
        if (util.isString(v)) return v;
      }

      for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {
        v = f ? f(values[i]) : values[i];
      }

      return util.isDate(v) ? 'date' :
        util.isNumber(v)    ? 'number' :
        util.isBoolean(v)   ? 'boolean' :
        util.isString(v)    ? 'string' : null;
    }

    function typeAll(data, fields) {
      if (!data.length) return;
      var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);
      return fields.reduce(function(types, f) {
        return (types[f] = type(data, get(f)), types);
      }, {});
    }

    function infer(values, f, ignore) {
      values = util.array(values);
      f = util.$(f);
      var i, j, v;

      // types to test for, in precedence order
      var types = ['boolean', 'integer', 'number', 'date'];

      for (i=0; i<values.length; ++i) {
        // get next value to test
        v = f ? f(values[i]) : values[i];
        // test value against remaining types
        for (j=0; j<types.length; ++j) {
          if ((!ignore || !ignore.test(v)) && util.isValid(v) && !TESTS[types[j]](v)) {
            types.splice(j, 1);
            j -= 1;
          }
        }
        // if no types left, return 'string'
        if (types.length === 0) return 'string';
      }

      return types[0];
    }

    function inferAll(data, fields, ignore) {
      var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);
      return fields.reduce(function(types, f) {
        types[f] = infer(data, get(f), ignore);
        return types;
      }, {});
    }

    type.annotation = annotation;
    type.all = typeAll;
    type.infer = infer;
    type.inferAll = inferAll;
    type.parsers = PARSERS;
    var type_1 = type;

    var d3Dsv = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      factory(exports);
    }(commonjsGlobal, function (exports) {
      function dsv(delimiter) {
        return new Dsv(delimiter);
      }

      function objectConverter(columns) {
        return new Function("d", "return {" + columns.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
      }

      function customConverter(columns, f) {
        var object = objectConverter(columns);
        return function(row, i) {
          return f(object(row), i, columns);
        };
      }

      // Compute unique columns in order of discovery.
      function inferColumns(rows) {
        var columnSet = Object.create(null),
            columns = [];

        rows.forEach(function(row) {
          for (var column in row) {
            if (!(column in columnSet)) {
              columns.push(columnSet[column] = column);
            }
          }
        });

        return columns;
      }

      function Dsv(delimiter) {
        var reFormat = new RegExp("[\"" + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);

        this.parse = function(text, f) {
          var convert, columns, rows = this.parseRows(text, function(row, i) {
            if (convert) return convert(row, i - 1);
            columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
          });
          rows.columns = columns;
          return rows;
        };

        this.parseRows = function(text, f) {
          var EOL = {}, // sentinel value for end-of-line
              EOF = {}, // sentinel value for end-of-file
              rows = [], // output rows
              N = text.length,
              I = 0, // current character index
              n = 0, // the current line number
              t, // the current token
              eol; // is the current token followed by EOL?

          function token() {
            if (I >= N) return EOF; // special case: end of file
            if (eol) return eol = false, EOL; // special case: end of line

            // special case: quotes
            var j = I, c;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34) break;
                  ++i;
                }
              }
              I = i + 2;
              c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10) ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, "\"");
            }

            // common case: find next delimiter or newline
            while (I < N) {
              var k = 1;
              c = text.charCodeAt(I++);
              if (c === 10) eol = true; // \n
              else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
              else if (c !== delimiterCode) continue;
              return text.slice(j, I - k);
            }

            // special case: last token before EOF
            return text.slice(j);
          }

          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null) continue;
            rows.push(a);
          }

          return rows;
        };

        this.format = function(rows, columns) {
          if (columns == null) columns = inferColumns(rows);
          return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
            return columns.map(function(column) {
              return formatValue(row[column]);
            }).join(delimiter);
          })).join("\n");
        };

        this.formatRows = function(rows) {
          return rows.map(formatRow).join("\n");
        };

        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }

        function formatValue(text) {
          return reFormat.test(text) ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
        }
      }

      dsv.prototype = Dsv.prototype;

      var csv = dsv(",");
      var tsv = dsv("\t");

      var version = "0.1.14";

      exports.version = version;
      exports.dsv = dsv;
      exports.csv = csv;
      exports.tsv = tsv;

    }));
    });

    function dsv(data, format) {
      if (data) {
        var h = format.header;
        data = (h ? h.join(format.delimiter) + '\n' : '') + data;
      }
      return d3Dsv.dsv(format.delimiter).parse(data);
    }

    dsv.delimiter = function(delim) {
      var fmt = {delimiter: delim};
      return function(data, format) {
        return dsv(data, format ? util.extend(format, fmt) : fmt);
      };
    };

    var dsv_1 = dsv;

    var json = function(data, format) {
      var d = util.isObject(data) && !util.isBuffer(data) ?
        data : JSON.parse(data);
      if (format && format.property) {
        d = util.accessor(format.property)(d);
      }
      return d;
    };

    function identity(x) {
      return x;
    }

    function transform(transform) {
      if (transform == null) return identity;
      var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1];
      return function(input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2, n = input.length, output = new Array(n);
        output[0] = (x0 += input[0]) * kx + dx;
        output[1] = (y0 += input[1]) * ky + dy;
        while (j < n) output[j] = input[j], ++j;
        return output;
      };
    }

    function bbox(topology) {
      var t = transform(topology.transform), key,
          x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

      function bboxPoint(p) {
        p = t(p);
        if (p[0] < x0) x0 = p[0];
        if (p[0] > x1) x1 = p[0];
        if (p[1] < y0) y0 = p[1];
        if (p[1] > y1) y1 = p[1];
      }

      function bboxGeometry(o) {
        switch (o.type) {
          case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
          case "Point": bboxPoint(o.coordinates); break;
          case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
        }
      }

      topology.arcs.forEach(function(arc) {
        var i = -1, n = arc.length, p;
        while (++i < n) {
          p = t(arc[i], i);
          if (p[0] < x0) x0 = p[0];
          if (p[0] > x1) x1 = p[0];
          if (p[1] < y0) y0 = p[1];
          if (p[1] > y1) y1 = p[1];
        }
      });

      for (key in topology.objects) {
        bboxGeometry(topology.objects[key]);
      }

      return [x0, y0, x1, y1];
    }

    function reverse(array, n) {
      var t, j = array.length, i = j - n;
      while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
    }

    function feature(topology, o) {
      return o.type === "GeometryCollection"
          ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
          : feature$1(topology, o);
    }

    function feature$1(topology, o) {
      var id = o.id,
          bbox = o.bbox,
          properties = o.properties == null ? {} : o.properties,
          geometry = object(topology, o);
      return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
          : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
          : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
    }

    function object(topology, o) {
      var transformPoint = transform(topology.transform),
          arcs = topology.arcs;

      function arc(i, points) {
        if (points.length) points.pop();
        for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
          points.push(transformPoint(a[k], k));
        }
        if (i < 0) reverse(points, n);
      }

      function point(p) {
        return transformPoint(p);
      }

      function line(arcs) {
        var points = [];
        for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
        if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
        return points;
      }

      function ring(arcs) {
        var points = line(arcs);
        while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
        return points;
      }

      function polygon(arcs) {
        return arcs.map(ring);
      }

      function geometry(o) {
        var type = o.type, coordinates;
        switch (type) {
          case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
          case "Point": coordinates = point(o.coordinates); break;
          case "MultiPoint": coordinates = o.coordinates.map(point); break;
          case "LineString": coordinates = line(o.arcs); break;
          case "MultiLineString": coordinates = o.arcs.map(line); break;
          case "Polygon": coordinates = polygon(o.arcs); break;
          case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
          default: return null;
        }
        return {type: type, coordinates: coordinates};
      }

      return geometry(o);
    }

    function stitch(topology, arcs) {
      var stitchedArcs = {},
          fragmentByStart = {},
          fragmentByEnd = {},
          fragments = [],
          emptyIndex = -1;

      // Stitch empty arcs first, since they may be subsumed by other arcs.
      arcs.forEach(function(i, j) {
        var arc = topology.arcs[i < 0 ? ~i : i], t;
        if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
          t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
        }
      });

      arcs.forEach(function(i) {
        var e = ends(i),
            start = e[0],
            end = e[1],
            f, g;

        if (f = fragmentByEnd[start]) {
          delete fragmentByEnd[f.end];
          f.push(i);
          f.end = end;
          if (g = fragmentByStart[end]) {
            delete fragmentByStart[g.start];
            var fg = g === f ? f : f.concat(g);
            fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else if (f = fragmentByStart[end]) {
          delete fragmentByStart[f.start];
          f.unshift(i);
          f.start = start;
          if (g = fragmentByEnd[start]) {
            delete fragmentByEnd[g.end];
            var gf = g === f ? f : g.concat(f);
            fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else {
          f = [i];
          fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }
      });

      function ends(i) {
        var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
        if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
        else p1 = arc[arc.length - 1];
        return i < 0 ? [p1, p0] : [p0, p1];
      }

      function flush(fragmentByEnd, fragmentByStart) {
        for (var k in fragmentByEnd) {
          var f = fragmentByEnd[k];
          delete fragmentByStart[f.start];
          delete f.start;
          delete f.end;
          f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
          fragments.push(f);
        }
      }

      flush(fragmentByEnd, fragmentByStart);
      flush(fragmentByStart, fragmentByEnd);
      arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

      return fragments;
    }

    function mesh(topology) {
      return object(topology, meshArcs.apply(this, arguments));
    }

    function meshArcs(topology, object$$1, filter) {
      var arcs, i, n;
      if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);
      else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
      return {type: "MultiLineString", arcs: stitch(topology, arcs)};
    }

    function extractArcs(topology, object$$1, filter) {
      var arcs = [],
          geomsByArc = [],
          geom;

      function extract0(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function extract1(arcs) {
        arcs.forEach(extract0);
      }

      function extract2(arcs) {
        arcs.forEach(extract1);
      }

      function extract3(arcs) {
        arcs.forEach(extract2);
      }

      function geometry(o) {
        switch (geom = o, o.type) {
          case "GeometryCollection": o.geometries.forEach(geometry); break;
          case "LineString": extract1(o.arcs); break;
          case "MultiLineString": case "Polygon": extract2(o.arcs); break;
          case "MultiPolygon": extract3(o.arcs); break;
        }
      }

      geometry(object$$1);

      geomsByArc.forEach(filter == null
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

      return arcs;
    }

    function planarRingArea(ring) {
      var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
      while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
      return Math.abs(area); // Note: doubled area!
    }

    function merge(topology) {
      return object(topology, mergeArcs.apply(this, arguments));
    }

    function mergeArcs(topology, objects) {
      var polygonsByArc = {},
          polygons = [],
          groups = [];

      objects.forEach(geometry);

      function geometry(o) {
        switch (o.type) {
          case "GeometryCollection": o.geometries.forEach(geometry); break;
          case "Polygon": extract(o.arcs); break;
          case "MultiPolygon": o.arcs.forEach(extract); break;
        }
      }

      function extract(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
          });
        });
        polygons.push(polygon);
      }

      function area(ring) {
        return planarRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
      }

      polygons.forEach(function(polygon) {
        if (!polygon._) {
          var group = [],
              neighbors = [polygon];
          polygon._ = 1;
          groups.push(group);
          while (polygon = neighbors.pop()) {
            group.push(polygon);
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                  if (!polygon._) {
                    polygon._ = 1;
                    neighbors.push(polygon);
                  }
                });
              });
            });
          }
        }
      });

      polygons.forEach(function(polygon) {
        delete polygon._;
      });

      return {
        type: "MultiPolygon",
        arcs: groups.map(function(polygons) {
          var arcs = [], n;

          // Extract the exterior (unique) arcs.
          polygons.forEach(function(polygon) {
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                  arcs.push(arc);
                }
              });
            });
          });

          // Stitch the arcs into one or more rings.
          arcs = stitch(topology, arcs);

          // If more than one ring is returned,
          // at most one of these rings can be the exterior;
          // choose the one with the greatest absolute area.
          if ((n = arcs.length) > 1) {
            for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
              if ((ki = area(arcs[i])) > k) {
                t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
              }
            }
          }

          return arcs;
        })
      };
    }

    function bisect(a, x) {
      var lo = 0, hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid] < x) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    }

    function neighbors(objects) {
      var indexesByArc = {}, // arc index -> array of object indexes
          neighbors = objects.map(function() { return []; });

      function line(arcs, i) {
        arcs.forEach(function(a) {
          if (a < 0) a = ~a;
          var o = indexesByArc[a];
          if (o) o.push(i);
          else indexesByArc[a] = [i];
        });
      }

      function polygon(arcs, i) {
        arcs.forEach(function(arc) { line(arc, i); });
      }

      function geometry(o, i) {
        if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
        else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
      };

      objects.forEach(geometry);

      for (var i in indexesByArc) {
        for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
          for (var k = j + 1; k < m; ++k) {
            var ij = indexes[j], ik = indexes[k], n;
            if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
            if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
          }
        }
      }

      return neighbors;
    }

    function untransform(transform) {
      if (transform == null) return identity;
      var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1];
      return function(input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2,
            n = input.length,
            output = new Array(n),
            x1 = Math.round((input[0] - dx) / kx),
            y1 = Math.round((input[1] - dy) / ky);
        output[0] = x1 - x0, x0 = x1;
        output[1] = y1 - y0, y0 = y1;
        while (j < n) output[j] = input[j], ++j;
        return output;
      };
    }

    function quantize(topology, transform) {
      if (topology.transform) throw new Error("already quantized");

      if (!transform || !transform.scale) {
        if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
        box = topology.bbox || bbox(topology);
        var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
        transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
      } else {
        box = topology.bbox;
      }

      var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};

      function quantizePoint(point) {
        return t(point);
      }

      function quantizeGeometry(input) {
        var output;
        switch (input.type) {
          case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
          case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
          case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
          default: return input;
        }
        if (input.id != null) output.id = input.id;
        if (input.bbox != null) output.bbox = input.bbox;
        if (input.properties != null) output.properties = input.properties;
        return output;
      }

      function quantizeArc(input) {
        var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
        output[0] = t(input[0], 0);
        while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
        if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
        output.length = j;
        return output;
      }

      for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

      return {
        type: "Topology",
        bbox: box,
        transform: transform,
        objects: outputs,
        arcs: topology.arcs.map(quantizeArc)
      };
    }



    var topojsonClient = /*#__PURE__*/Object.freeze({
        bbox: bbox,
        feature: feature,
        mesh: mesh,
        meshArcs: meshArcs,
        merge: merge,
        mergeArcs: mergeArcs,
        neighbors: neighbors,
        quantize: quantize,
        transform: transform,
        untransform: untransform
    });

    var reader = function(data, format) {
      var topojson = reader.topojson;
      if (topojson == null) { throw Error('TopoJSON library not loaded.'); }

      var t = json(data, format), obj;

      if (format && format.feature) {
        if ((obj = t.objects[format.feature])) {
          return topojson.feature(t, obj).features;
        } else {
          throw Error('Invalid TopoJSON object: ' + format.feature);
        }
      } else if (format && format.mesh) {
        if ((obj = t.objects[format.mesh])) {
          return [topojson.mesh(t, t.objects[format.mesh])];
        } else {
          throw Error('Invalid TopoJSON object: ' + format.mesh);
        }
      } else {
        throw Error('Missing TopoJSON feature or mesh parameter.');
      }
    };

    reader.topojson = topojsonClient;
    var topojson = reader;

    var treejson = function(tree, format) {
      return toTable(json(tree, format), format);
    };

    function toTable(root, fields) {
      var childrenField = fields && fields.children || 'children',
          parentField = fields && fields.parent || 'parent',
          table = [];

      function visit(node, parent) {
        node[parentField] = parent;
        table.push(node);
        var children = node[childrenField];
        if (children) {
          for (var i=0; i<children.length; ++i) {
            visit(children[i], node);
          }
        }
      }

      visit(root, null);
      return (table.root = root, table);
    }

    var formats = {
      json: json,
      topojson: topojson,
      treejson: treejson,
      dsv: dsv_1,
      csv: dsv_1.delimiter(','),
      tsv: dsv_1.delimiter('\t')
    };

    var d3Time = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      factory(exports);
    }(commonjsGlobal, function (exports) {
      var t0 = new Date;
      var t1 = new Date;
      function newInterval(floori, offseti, count, field) {

        function interval(date) {
          return floori(date = new Date(+date)), date;
        }

        interval.floor = interval;

        interval.round = function(date) {
          var d0 = new Date(+date),
              d1 = new Date(date - 1);
          floori(d0), floori(d1), offseti(d1, 1);
          return date - d0 < d1 - date ? d0 : d1;
        };

        interval.ceil = function(date) {
          return floori(date = new Date(date - 1)), offseti(date, 1), date;
        };

        interval.offset = function(date, step) {
          return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
        };

        interval.range = function(start, stop, step) {
          var range = [];
          start = new Date(start - 1);
          stop = new Date(+stop);
          step = step == null ? 1 : Math.floor(step);
          if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
          offseti(start, 1), floori(start);
          if (start < stop) range.push(new Date(+start));
          while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
          return range;
        };

        interval.filter = function(test) {
          return newInterval(function(date) {
            while (floori(date), !test(date)) date.setTime(date - 1);
          }, function(date, step) {
            while (--step >= 0) while (offseti(date, 1), !test(date));
          });
        };

        if (count) {
          interval.count = function(start, end) {
            t0.setTime(+start), t1.setTime(+end);
            floori(t0), floori(t1);
            return Math.floor(count(t0, t1));
          };

          interval.every = function(step) {
            step = Math.floor(step);
            return !isFinite(step) || !(step > 0) ? null
                : !(step > 1) ? interval
                : interval.filter(field
                    ? function(d) { return field(d) % step === 0; }
                    : function(d) { return interval.count(0, d) % step === 0; });
          };
        }

        return interval;
      }
      var millisecond = newInterval(function() {
        // noop
      }, function(date, step) {
        date.setTime(+date + step);
      }, function(start, end) {
        return end - start;
      });

      // An optimized implementation for this simple case.
      millisecond.every = function(k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0)) return null;
        if (!(k > 1)) return millisecond;
        return newInterval(function(date) {
          date.setTime(Math.floor(date / k) * k);
        }, function(date, step) {
          date.setTime(+date + step * k);
        }, function(start, end) {
          return (end - start) / k;
        });
      };

      var second = newInterval(function(date) {
        date.setMilliseconds(0);
      }, function(date, step) {
        date.setTime(+date + step * 1e3);
      }, function(start, end) {
        return (end - start) / 1e3;
      }, function(date) {
        return date.getSeconds();
      });

      var minute = newInterval(function(date) {
        date.setSeconds(0, 0);
      }, function(date, step) {
        date.setTime(+date + step * 6e4);
      }, function(start, end) {
        return (end - start) / 6e4;
      }, function(date) {
        return date.getMinutes();
      });

      var hour = newInterval(function(date) {
        date.setMinutes(0, 0, 0);
      }, function(date, step) {
        date.setTime(+date + step * 36e5);
      }, function(start, end) {
        return (end - start) / 36e5;
      }, function(date) {
        return date.getHours();
      });

      var day = newInterval(function(date) {
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
      }, function(date) {
        return date.getDate() - 1;
      });

      function weekday(i) {
        return newInterval(function(date) {
          date.setHours(0, 0, 0, 0);
          date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        }, function(date, step) {
          date.setDate(date.getDate() + step * 7);
        }, function(start, end) {
          return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
        });
      }

      var sunday = weekday(0);
      var monday = weekday(1);
      var tuesday = weekday(2);
      var wednesday = weekday(3);
      var thursday = weekday(4);
      var friday = weekday(5);
      var saturday = weekday(6);

      var month = newInterval(function(date) {
        date.setHours(0, 0, 0, 0);
        date.setDate(1);
      }, function(date, step) {
        date.setMonth(date.getMonth() + step);
      }, function(start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
      }, function(date) {
        return date.getMonth();
      });

      var year = newInterval(function(date) {
        date.setHours(0, 0, 0, 0);
        date.setMonth(0, 1);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step);
      }, function(start, end) {
        return end.getFullYear() - start.getFullYear();
      }, function(date) {
        return date.getFullYear();
      });

      var utcSecond = newInterval(function(date) {
        date.setUTCMilliseconds(0);
      }, function(date, step) {
        date.setTime(+date + step * 1e3);
      }, function(start, end) {
        return (end - start) / 1e3;
      }, function(date) {
        return date.getUTCSeconds();
      });

      var utcMinute = newInterval(function(date) {
        date.setUTCSeconds(0, 0);
      }, function(date, step) {
        date.setTime(+date + step * 6e4);
      }, function(start, end) {
        return (end - start) / 6e4;
      }, function(date) {
        return date.getUTCMinutes();
      });

      var utcHour = newInterval(function(date) {
        date.setUTCMinutes(0, 0, 0);
      }, function(date, step) {
        date.setTime(+date + step * 36e5);
      }, function(start, end) {
        return (end - start) / 36e5;
      }, function(date) {
        return date.getUTCHours();
      });

      var utcDay = newInterval(function(date) {
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step);
      }, function(start, end) {
        return (end - start) / 864e5;
      }, function(date) {
        return date.getUTCDate() - 1;
      });

      function utcWeekday(i) {
        return newInterval(function(date) {
          date.setUTCHours(0, 0, 0, 0);
          date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        }, function(date, step) {
          date.setUTCDate(date.getUTCDate() + step * 7);
        }, function(start, end) {
          return (end - start) / 6048e5;
        });
      }

      var utcSunday = utcWeekday(0);
      var utcMonday = utcWeekday(1);
      var utcTuesday = utcWeekday(2);
      var utcWednesday = utcWeekday(3);
      var utcThursday = utcWeekday(4);
      var utcFriday = utcWeekday(5);
      var utcSaturday = utcWeekday(6);

      var utcMonth = newInterval(function(date) {
        date.setUTCHours(0, 0, 0, 0);
        date.setUTCDate(1);
      }, function(date, step) {
        date.setUTCMonth(date.getUTCMonth() + step);
      }, function(start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
      }, function(date) {
        return date.getUTCMonth();
      });

      var utcYear = newInterval(function(date) {
        date.setUTCHours(0, 0, 0, 0);
        date.setUTCMonth(0, 1);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step);
      }, function(start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear();
      }, function(date) {
        return date.getUTCFullYear();
      });

      var milliseconds = millisecond.range;
      var seconds = second.range;
      var minutes = minute.range;
      var hours = hour.range;
      var days = day.range;
      var sundays = sunday.range;
      var mondays = monday.range;
      var tuesdays = tuesday.range;
      var wednesdays = wednesday.range;
      var thursdays = thursday.range;
      var fridays = friday.range;
      var saturdays = saturday.range;
      var weeks = sunday.range;
      var months = month.range;
      var years = year.range;

      var utcMillisecond = millisecond;
      var utcMilliseconds = milliseconds;
      var utcSeconds = utcSecond.range;
      var utcMinutes = utcMinute.range;
      var utcHours = utcHour.range;
      var utcDays = utcDay.range;
      var utcSundays = utcSunday.range;
      var utcMondays = utcMonday.range;
      var utcTuesdays = utcTuesday.range;
      var utcWednesdays = utcWednesday.range;
      var utcThursdays = utcThursday.range;
      var utcFridays = utcFriday.range;
      var utcSaturdays = utcSaturday.range;
      var utcWeeks = utcSunday.range;
      var utcMonths = utcMonth.range;
      var utcYears = utcYear.range;

      var version = "0.1.1";

      exports.version = version;
      exports.milliseconds = milliseconds;
      exports.seconds = seconds;
      exports.minutes = minutes;
      exports.hours = hours;
      exports.days = days;
      exports.sundays = sundays;
      exports.mondays = mondays;
      exports.tuesdays = tuesdays;
      exports.wednesdays = wednesdays;
      exports.thursdays = thursdays;
      exports.fridays = fridays;
      exports.saturdays = saturdays;
      exports.weeks = weeks;
      exports.months = months;
      exports.years = years;
      exports.utcMillisecond = utcMillisecond;
      exports.utcMilliseconds = utcMilliseconds;
      exports.utcSeconds = utcSeconds;
      exports.utcMinutes = utcMinutes;
      exports.utcHours = utcHours;
      exports.utcDays = utcDays;
      exports.utcSundays = utcSundays;
      exports.utcMondays = utcMondays;
      exports.utcTuesdays = utcTuesdays;
      exports.utcWednesdays = utcWednesdays;
      exports.utcThursdays = utcThursdays;
      exports.utcFridays = utcFridays;
      exports.utcSaturdays = utcSaturdays;
      exports.utcWeeks = utcWeeks;
      exports.utcMonths = utcMonths;
      exports.utcYears = utcYears;
      exports.millisecond = millisecond;
      exports.second = second;
      exports.minute = minute;
      exports.hour = hour;
      exports.day = day;
      exports.sunday = sunday;
      exports.monday = monday;
      exports.tuesday = tuesday;
      exports.wednesday = wednesday;
      exports.thursday = thursday;
      exports.friday = friday;
      exports.saturday = saturday;
      exports.week = sunday;
      exports.month = month;
      exports.year = year;
      exports.utcSecond = utcSecond;
      exports.utcMinute = utcMinute;
      exports.utcHour = utcHour;
      exports.utcDay = utcDay;
      exports.utcSunday = utcSunday;
      exports.utcMonday = utcMonday;
      exports.utcTuesday = utcTuesday;
      exports.utcWednesday = utcWednesday;
      exports.utcThursday = utcThursday;
      exports.utcFriday = utcFriday;
      exports.utcSaturday = utcSaturday;
      exports.utcWeek = utcSunday;
      exports.utcMonth = utcMonth;
      exports.utcYear = utcYear;
      exports.interval = newInterval;

    }));
    });

    var d3TimeFormat = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      factory(exports, d3Time);
    }(commonjsGlobal, function (exports,d3Time$$1) {
      function localDate(d) {
        if (0 <= d.y && d.y < 100) {
          var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
          date.setFullYear(d.y);
          return date;
        }
        return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
      }

      function utcDate(d) {
        if (0 <= d.y && d.y < 100) {
          var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
          date.setUTCFullYear(d.y);
          return date;
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
      }

      function newYear(y) {
        return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
      }

      function locale$1(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_weekdays = locale.days,
            locale_shortWeekdays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;

        var periodRe = formatRe(locale_periods),
            periodLookup = formatLookup(locale_periods),
            weekdayRe = formatRe(locale_weekdays),
            weekdayLookup = formatLookup(locale_weekdays),
            shortWeekdayRe = formatRe(locale_shortWeekdays),
            shortWeekdayLookup = formatLookup(locale_shortWeekdays),
            monthRe = formatRe(locale_months),
            monthLookup = formatLookup(locale_months),
            shortMonthRe = formatRe(locale_shortMonths),
            shortMonthLookup = formatLookup(locale_shortMonths);

        var formats = {
          "a": formatShortWeekday,
          "A": formatWeekday,
          "b": formatShortMonth,
          "B": formatMonth,
          "c": null,
          "d": formatDayOfMonth,
          "e": formatDayOfMonth,
          "H": formatHour24,
          "I": formatHour12,
          "j": formatDayOfYear,
          "L": formatMilliseconds,
          "m": formatMonthNumber,
          "M": formatMinutes,
          "p": formatPeriod,
          "S": formatSeconds,
          "U": formatWeekNumberSunday,
          "w": formatWeekdayNumber,
          "W": formatWeekNumberMonday,
          "x": null,
          "X": null,
          "y": formatYear,
          "Y": formatFullYear,
          "Z": formatZone,
          "%": formatLiteralPercent
        };

        var utcFormats = {
          "a": formatUTCShortWeekday,
          "A": formatUTCWeekday,
          "b": formatUTCShortMonth,
          "B": formatUTCMonth,
          "c": null,
          "d": formatUTCDayOfMonth,
          "e": formatUTCDayOfMonth,
          "H": formatUTCHour24,
          "I": formatUTCHour12,
          "j": formatUTCDayOfYear,
          "L": formatUTCMilliseconds,
          "m": formatUTCMonthNumber,
          "M": formatUTCMinutes,
          "p": formatUTCPeriod,
          "S": formatUTCSeconds,
          "U": formatUTCWeekNumberSunday,
          "w": formatUTCWeekdayNumber,
          "W": formatUTCWeekNumberMonday,
          "x": null,
          "X": null,
          "y": formatUTCYear,
          "Y": formatUTCFullYear,
          "Z": formatUTCZone,
          "%": formatLiteralPercent
        };

        var parses = {
          "a": parseShortWeekday,
          "A": parseWeekday,
          "b": parseShortMonth,
          "B": parseMonth,
          "c": parseLocaleDateTime,
          "d": parseDayOfMonth,
          "e": parseDayOfMonth,
          "H": parseHour24,
          "I": parseHour24,
          "j": parseDayOfYear,
          "L": parseMilliseconds,
          "m": parseMonthNumber,
          "M": parseMinutes,
          "p": parsePeriod,
          "S": parseSeconds,
          "U": parseWeekNumberSunday,
          "w": parseWeekdayNumber,
          "W": parseWeekNumberMonday,
          "x": parseLocaleDate,
          "X": parseLocaleTime,
          "y": parseYear,
          "Y": parseFullYear,
          "Z": parseZone,
          "%": parseLiteralPercent
        };

        // These recursive directive definitions must be deferred.
        formats.x = newFormat(locale_date, formats);
        formats.X = newFormat(locale_time, formats);
        formats.c = newFormat(locale_dateTime, formats);
        utcFormats.x = newFormat(locale_date, utcFormats);
        utcFormats.X = newFormat(locale_time, utcFormats);
        utcFormats.c = newFormat(locale_dateTime, utcFormats);

        function newFormat(specifier, formats) {
          return function(date) {
            var string = [],
                i = -1,
                j = 0,
                n = specifier.length,
                c,
                pad,
                format;

            if (!(date instanceof Date)) date = new Date(+date);

            while (++i < n) {
              if (specifier.charCodeAt(i) === 37) {
                string.push(specifier.slice(j, i));
                if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
                else pad = c === "e" ? " " : "0";
                if (format = formats[c]) c = format(date, pad);
                string.push(c);
                j = i + 1;
              }
            }

            string.push(specifier.slice(j, i));
            return string.join("");
          };
        }

        function newParse(specifier, newDate) {
          return function(string) {
            var d = newYear(1900),
                i = parseSpecifier(d, specifier, string += "", 0);
            if (i != string.length) return null;

            // The am-pm flag is 0 for AM, and 1 for PM.
            if ("p" in d) d.H = d.H % 12 + d.p * 12;

            // Convert day-of-week and week-of-year to day-of-year.
            if ("W" in d || "U" in d) {
              if (!("w" in d)) d.w = "W" in d ? 1 : 0;
              var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
              d.m = 0;
              d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
            }

            // If a time zone is specified, all fields are interpreted as UTC and then
            // offset according to the specified time zone.
            if ("Z" in d) {
              d.H += d.Z / 100 | 0;
              d.M += d.Z % 100;
              return utcDate(d);
            }

            // Otherwise, all fields are in local time.
            return newDate(d);
          };
        }

        function parseSpecifier(d, specifier, string, j) {
          var i = 0,
              n = specifier.length,
              m = string.length,
              c,
              parse;

          while (i < n) {
            if (j >= m) return -1;
            c = specifier.charCodeAt(i++);
            if (c === 37) {
              c = specifier.charAt(i++);
              parse = parses[c in pads ? specifier.charAt(i++) : c];
              if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }

          return j;
        }

        function parsePeriod(d, string, i) {
          var n = periodRe.exec(string.slice(i));
          return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }

        function parseShortWeekday(d, string, i) {
          var n = shortWeekdayRe.exec(string.slice(i));
          return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }

        function parseWeekday(d, string, i) {
          var n = weekdayRe.exec(string.slice(i));
          return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }

        function parseShortMonth(d, string, i) {
          var n = shortMonthRe.exec(string.slice(i));
          return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }

        function parseMonth(d, string, i) {
          var n = monthRe.exec(string.slice(i));
          return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }

        function parseLocaleDateTime(d, string, i) {
          return parseSpecifier(d, locale_dateTime, string, i);
        }

        function parseLocaleDate(d, string, i) {
          return parseSpecifier(d, locale_date, string, i);
        }

        function parseLocaleTime(d, string, i) {
          return parseSpecifier(d, locale_time, string, i);
        }

        function formatShortWeekday(d) {
          return locale_shortWeekdays[d.getDay()];
        }

        function formatWeekday(d) {
          return locale_weekdays[d.getDay()];
        }

        function formatShortMonth(d) {
          return locale_shortMonths[d.getMonth()];
        }

        function formatMonth(d) {
          return locale_months[d.getMonth()];
        }

        function formatPeriod(d) {
          return locale_periods[+(d.getHours() >= 12)];
        }

        function formatUTCShortWeekday(d) {
          return locale_shortWeekdays[d.getUTCDay()];
        }

        function formatUTCWeekday(d) {
          return locale_weekdays[d.getUTCDay()];
        }

        function formatUTCShortMonth(d) {
          return locale_shortMonths[d.getUTCMonth()];
        }

        function formatUTCMonth(d) {
          return locale_months[d.getUTCMonth()];
        }

        function formatUTCPeriod(d) {
          return locale_periods[+(d.getUTCHours() >= 12)];
        }

        return {
          format: function(specifier) {
            var f = newFormat(specifier += "", formats);
            f.parse = newParse(specifier, localDate);
            f.toString = function() { return specifier; };
            return f;
          },
          utcFormat: function(specifier) {
            var f = newFormat(specifier += "", utcFormats);
            f.parse = newParse(specifier, utcDate);
            f.toString = function() { return specifier; };
            return f;
          }
        };
      }
      var pads = {"-": "", "_": " ", "0": "0"};
      var numberRe = /^\s*\d+/;
      var percentRe = /^%/;
      var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      function pad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }

      function requote(s) {
        return s.replace(requoteRe, "\\$&");
      }

      function formatRe(names) {
        return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
      }

      function formatLookup(names) {
        var map = {}, i = -1, n = names.length;
        while (++i < n) map[names[i].toLowerCase()] = i;
        return map;
      }

      function parseWeekdayNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.w = +n[0], i + n[0].length) : -1;
      }

      function parseWeekNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.U = +n[0], i + n[0].length) : -1;
      }

      function parseWeekNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.W = +n[0], i + n[0].length) : -1;
      }

      function parseFullYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 4));
        return n ? (d.y = +n[0], i + n[0].length) : -1;
      }

      function parseYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
      }

      function parseZone(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
      }

      function parseMonthNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
      }

      function parseDayOfMonth(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.d = +n[0], i + n[0].length) : -1;
      }

      function parseDayOfYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
      }

      function parseHour24(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.H = +n[0], i + n[0].length) : -1;
      }

      function parseMinutes(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.M = +n[0], i + n[0].length) : -1;
      }

      function parseSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.S = +n[0], i + n[0].length) : -1;
      }

      function parseMilliseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.L = +n[0], i + n[0].length) : -1;
      }

      function parseLiteralPercent(d, string, i) {
        var n = percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }

      function formatDayOfMonth(d, p) {
        return pad(d.getDate(), p, 2);
      }

      function formatHour24(d, p) {
        return pad(d.getHours(), p, 2);
      }

      function formatHour12(d, p) {
        return pad(d.getHours() % 12 || 12, p, 2);
      }

      function formatDayOfYear(d, p) {
        return pad(1 + d3Time$$1.day.count(d3Time$$1.year(d), d), p, 3);
      }

      function formatMilliseconds(d, p) {
        return pad(d.getMilliseconds(), p, 3);
      }

      function formatMonthNumber(d, p) {
        return pad(d.getMonth() + 1, p, 2);
      }

      function formatMinutes(d, p) {
        return pad(d.getMinutes(), p, 2);
      }

      function formatSeconds(d, p) {
        return pad(d.getSeconds(), p, 2);
      }

      function formatWeekNumberSunday(d, p) {
        return pad(d3Time$$1.sunday.count(d3Time$$1.year(d), d), p, 2);
      }

      function formatWeekdayNumber(d) {
        return d.getDay();
      }

      function formatWeekNumberMonday(d, p) {
        return pad(d3Time$$1.monday.count(d3Time$$1.year(d), d), p, 2);
      }

      function formatYear(d, p) {
        return pad(d.getFullYear() % 100, p, 2);
      }

      function formatFullYear(d, p) {
        return pad(d.getFullYear() % 10000, p, 4);
      }

      function formatZone(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? "-" : (z *= -1, "+"))
            + pad(z / 60 | 0, "0", 2)
            + pad(z % 60, "0", 2);
      }

      function formatUTCDayOfMonth(d, p) {
        return pad(d.getUTCDate(), p, 2);
      }

      function formatUTCHour24(d, p) {
        return pad(d.getUTCHours(), p, 2);
      }

      function formatUTCHour12(d, p) {
        return pad(d.getUTCHours() % 12 || 12, p, 2);
      }

      function formatUTCDayOfYear(d, p) {
        return pad(1 + d3Time$$1.utcDay.count(d3Time$$1.utcYear(d), d), p, 3);
      }

      function formatUTCMilliseconds(d, p) {
        return pad(d.getUTCMilliseconds(), p, 3);
      }

      function formatUTCMonthNumber(d, p) {
        return pad(d.getUTCMonth() + 1, p, 2);
      }

      function formatUTCMinutes(d, p) {
        return pad(d.getUTCMinutes(), p, 2);
      }

      function formatUTCSeconds(d, p) {
        return pad(d.getUTCSeconds(), p, 2);
      }

      function formatUTCWeekNumberSunday(d, p) {
        return pad(d3Time$$1.utcSunday.count(d3Time$$1.utcYear(d), d), p, 2);
      }

      function formatUTCWeekdayNumber(d) {
        return d.getUTCDay();
      }

      function formatUTCWeekNumberMonday(d, p) {
        return pad(d3Time$$1.utcMonday.count(d3Time$$1.utcYear(d), d), p, 2);
      }

      function formatUTCYear(d, p) {
        return pad(d.getUTCFullYear() % 100, p, 2);
      }

      function formatUTCFullYear(d, p) {
        return pad(d.getUTCFullYear() % 10000, p, 4);
      }

      function formatUTCZone() {
        return "+0000";
      }

      function formatLiteralPercent() {
        return "%";
      }

      var locale = locale$1({
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });

      var caES = locale$1({
        dateTime: "%A, %e de %B de %Y, %X",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte"],
        shortDays: ["dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds."],
        months: ["gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre"],
        shortMonths: ["gen.", "febr.", "març", "abr.", "maig", "juny", "jul.", "ag.", "set.", "oct.", "nov.", "des."]
      });

      var deCH = locale$1({
        dateTime: "%A, der %e. %B %Y, %X",
        date: "%d.%m.%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"], // unused
        days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
        shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
        months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
        shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
      });

      var deDE = locale$1({
        dateTime: "%A, der %e. %B %Y, %X",
        date: "%d.%m.%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"], // unused
        days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
        shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
        months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
        shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
      });

      var enCA = locale$1({
        dateTime: "%a %b %e %X %Y",
        date: "%Y-%m-%d",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });

      var enGB = locale$1({
        dateTime: "%a %e %b %X %Y",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });

      var esES = locale$1({
        dateTime: "%A, %e de %B de %Y, %X",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"],
        shortDays: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
        months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
        shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"]
      });

      var fiFI = locale$1({
        dateTime: "%A, %-d. %Bta %Y klo %X",
        date: "%-d.%-m.%Y",
        time: "%H:%M:%S",
        periods: ["a.m.", "p.m."],
        days: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"],
        shortDays: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
        months: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"],
        shortMonths: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kesä", "Heinä", "Elo", "Syys", "Loka", "Marras", "Joulu"]
      });

      var frCA = locale$1({
        dateTime: "%a %e %b %Y %X",
        date: "%Y-%m-%d",
        time: "%H:%M:%S",
        periods: ["", ""],
        days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
        shortDays: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
        months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
        shortMonths: ["jan", "fév", "mar", "avr", "mai", "jui", "jul", "aoû", "sep", "oct", "nov", "déc"]
      });

      var frFR = locale$1({
        dateTime: "%A, le %e %B %Y, %X",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"], // unused
        days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
        shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
        months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
        shortMonths: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
      });

      var heIL = locale$1({
        dateTime: "%A, %e ב%B %Y %X",
        date: "%d.%m.%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
        shortDays: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
        months: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
        shortMonths: ["ינו׳", "פבר׳", "מרץ", "אפר׳", "מאי", "יוני", "יולי", "אוג׳", "ספט׳", "אוק׳", "נוב׳", "דצמ׳"]
      });

      var huHU = locale$1({
        dateTime: "%Y. %B %-e., %A %X",
        date: "%Y. %m. %d.",
        time: "%H:%M:%S",
        periods: ["de.", "du."], // unused
        days: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"],
        shortDays: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
        months: ["január", "február", "március", "április", "május", "június", "július", "augusztus", "szeptember", "október", "november", "december"],
        shortMonths: ["jan.", "feb.", "már.", "ápr.", "máj.", "jún.", "júl.", "aug.", "szept.", "okt.", "nov.", "dec."]
      });

      var itIT = locale$1({
        dateTime: "%A %e %B %Y, %X",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"], // unused
        days: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
        shortDays: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
        months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
        shortMonths: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
      });

      var jaJP = locale$1({
        dateTime: "%Y %b %e %a %X",
        date: "%Y/%m/%d",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
        shortDays: ["日", "月", "火", "水", "木", "金", "土"],
        months: ["睦月", "如月", "弥生", "卯月", "皐月", "水無月", "文月", "葉月", "長月", "神無月", "霜月", "師走"],
        shortMonths: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
      });

      var koKR = locale$1({
        dateTime: "%Y/%m/%d %a %X",
        date: "%Y/%m/%d",
        time: "%H:%M:%S",
        periods: ["오전", "오후"],
        days: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"],
        shortDays: ["일", "월", "화", "수", "목", "금", "토"],
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        shortMonths: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"]
      });

      var mkMK = locale$1({
        dateTime: "%A, %e %B %Y г. %X",
        date: "%d.%m.%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"],
        shortDays: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
        months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
        shortMonths: ["јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек"]
      });

      var nlNL = locale$1({
        dateTime: "%a %e %B %Y %T",
        date: "%d-%m-%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"], // unused
        days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
        shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
        months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
      });

      var plPL = locale$1({
        dateTime: "%A, %e %B %Y, %X",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"], // unused
        days: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
        shortDays: ["Niedz.", "Pon.", "Wt.", "Śr.", "Czw.", "Pt.", "Sob."],
        months: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
        shortMonths: ["Stycz.", "Luty", "Marz.", "Kwie.", "Maj", "Czerw.", "Lipc.", "Sierp.", "Wrz.", "Paźdz.", "Listop.", "Grudz."]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */
      });

      var ptBR = locale$1({
        dateTime: "%A, %e de %B de %Y. %X",
        date: "%d/%m/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
        shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
      });

      var ruRU = locale$1({
        dateTime: "%A, %e %B %Y г. %X",
        date: "%d.%m.%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
        shortDays: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
        months: ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
        shortMonths: ["янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек"]
      });

      var svSE = locale$1({
        dateTime: "%A den %d %B %Y %X",
        date: "%Y-%m-%d",
        time: "%H:%M:%S",
        periods: ["fm", "em"],
        days: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"],
        shortDays: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"]
      });

      var zhCN = locale$1({
        dateTime: "%a %b %e %X %Y",
        date: "%Y/%-m/%-d",
        time: "%H:%M:%S",
        periods: ["上午", "下午"],
        days: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
        shortDays: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        shortMonths: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
      });

      var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

      function formatIsoNative(date) {
        return date.toISOString();
      }

      formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };

      formatIsoNative.toString = function() {
        return isoSpecifier;
      };

      var formatIso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z")
          ? formatIsoNative
          : locale.utcFormat(isoSpecifier);

      var format = locale.format;
      var utcFormat = locale.utcFormat;

      var version = "0.2.1";

      exports.version = version;
      exports.format = format;
      exports.utcFormat = utcFormat;
      exports.locale = locale$1;
      exports.localeCaEs = caES;
      exports.localeDeCh = deCH;
      exports.localeDeDe = deDE;
      exports.localeEnCa = enCA;
      exports.localeEnGb = enGB;
      exports.localeEnUs = locale;
      exports.localeEsEs = esES;
      exports.localeFiFi = fiFI;
      exports.localeFrCa = frCA;
      exports.localeFrFr = frFR;
      exports.localeHeIl = heIL;
      exports.localeHuHu = huHU;
      exports.localeItIt = itIT;
      exports.localeJaJp = jaJP;
      exports.localeKoKr = koKR;
      exports.localeMkMk = mkMK;
      exports.localeNlNl = nlNL;
      exports.localePlPl = plPL;
      exports.localePtBr = ptBR;
      exports.localeRuRu = ruRU;
      exports.localeSvSe = svSE;
      exports.localeZhCn = zhCN;
      exports.isoFormat = formatIso;

    }));
    });

    var d3Format = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      factory(exports);
    }(commonjsGlobal, function (exports) {
      // Computes the decimal coefficient and exponent of the specified number x with
      // significant digits p, where x is positive and p is in [1, 21] or undefined.
      // For example, formatDecimal(1.23) returns ["123", 0].
      function formatDecimal(x, p) {
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
        var i, coefficient = x.slice(0, i);

        // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
        // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
        return [
          coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
          +x.slice(i + 1)
        ];
      }
      function exponent(x) {
        return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
      }
      function formatGroup(grouping, thousands) {
        return function(value, width) {
          var i = value.length,
              t = [],
              j = 0,
              g = grouping[0],
              length = 0;

          while (i > 0 && g > 0) {
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
          }

          return t.reverse().join(thousands);
        };
      }
      var prefixExponent;

      function formatPrefixAuto(x, p) {
        var d = formatDecimal(x, p);
        if (!d) return x + "";
        var coefficient = d[0],
            exponent = d[1],
            i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
            n = coefficient.length;
        return i === n ? coefficient
            : i > n ? coefficient + new Array(i - n + 1).join("0")
            : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
            : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
      }
      function formatRounded(x, p) {
        var d = formatDecimal(x, p);
        if (!d) return x + "";
        var coefficient = d[0],
            exponent = d[1];
        return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
            : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
            : coefficient + new Array(exponent - coefficient.length + 2).join("0");
      }
      function formatDefault(x, p) {
        x = x.toPrecision(p);

        out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
          switch (x[i]) {
            case ".": i0 = i1 = i; break;
            case "0": if (i0 === 0) i0 = i; i1 = i; break;
            case "e": break out;
            default: if (i0 > 0) i0 = 0; break;
          }
        }

        return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
      }
      var formatTypes = {
        "": formatDefault,
        "%": function(x, p) { return (x * 100).toFixed(p); },
        "b": function(x) { return Math.round(x).toString(2); },
        "c": function(x) { return x + ""; },
        "d": function(x) { return Math.round(x).toString(10); },
        "e": function(x, p) { return x.toExponential(p); },
        "f": function(x, p) { return x.toFixed(p); },
        "g": function(x, p) { return x.toPrecision(p); },
        "o": function(x) { return Math.round(x).toString(8); },
        "p": function(x, p) { return formatRounded(x * 100, p); },
        "r": formatRounded,
        "s": formatPrefixAuto,
        "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
        "x": function(x) { return Math.round(x).toString(16); }
      };

      // [[fill]align][sign][symbol][0][width][,][.precision][type]
      var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

      function formatSpecifier(specifier) {
        return new FormatSpecifier(specifier);
      }
      function FormatSpecifier(specifier) {
        if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

        var match,
            fill = match[1] || " ",
            align = match[2] || ">",
            sign = match[3] || "-",
            symbol = match[4] || "",
            zero = !!match[5],
            width = match[6] && +match[6],
            comma = !!match[7],
            precision = match[8] && +match[8].slice(1),
            type = match[9] || "";

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // Map invalid types to the default format.
        else if (!formatTypes[type]) type = "";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        this.fill = fill;
        this.align = align;
        this.sign = sign;
        this.symbol = symbol;
        this.zero = zero;
        this.width = width;
        this.comma = comma;
        this.precision = precision;
        this.type = type;
      }

      FormatSpecifier.prototype.toString = function() {
        return this.fill
            + this.align
            + this.sign
            + this.symbol
            + (this.zero ? "0" : "")
            + (this.width == null ? "" : Math.max(1, this.width | 0))
            + (this.comma ? "," : "")
            + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
            + this.type;
      };

      var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

      function identity(x) {
        return x;
      }

      function locale(locale) {
        var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
            currency = locale.currency,
            decimal = locale.decimal;

        function format(specifier) {
          specifier = formatSpecifier(specifier);

          var fill = specifier.fill,
              align = specifier.align,
              sign = specifier.sign,
              symbol = specifier.symbol,
              zero = specifier.zero,
              width = specifier.width,
              comma = specifier.comma,
              precision = specifier.precision,
              type = specifier.type;

          // Compute the prefix and suffix.
          // For SI-prefix, the suffix is lazily computed.
          var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
              suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

          // What format function should we use?
          // Is this an integer type?
          // Can this type generate exponential notation?
          var formatType = formatTypes[type],
              maybeSuffix = !type || /[defgprs%]/.test(type);

          // Set the default precision if not specified,
          // or clamp the specified precision to the supported range.
          // For significant precision, it must be in [1, 21].
          // For fixed precision, it must be in [0, 20].
          precision = precision == null ? (type ? 6 : 12)
              : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
              : Math.max(0, Math.min(20, precision));

          return function(value) {
            var valuePrefix = prefix,
                valueSuffix = suffix;

            if (type === "c") {
              valueSuffix = formatType(value) + valueSuffix;
              value = "";
            } else {
              value = +value;

              // Convert negative to positive, and compute the prefix.
              // Note that -0 is not less than 0, but 1 / -0 is!
              var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

              // Perform the initial formatting.
              value = formatType(value, precision);

              // If the original value was negative, it may be rounded to zero during
              // formatting; treat this as (positive) zero.
              if (valueNegative) {
                var i = -1, n = value.length, c;
                valueNegative = false;
                while (++i < n) {
                  if (c = value.charCodeAt(i), (48 < c && c < 58)
                      || (type === "x" && 96 < c && c < 103)
                      || (type === "X" && 64 < c && c < 71)) {
                    valueNegative = true;
                    break;
                  }
                }
              }

              // Compute the prefix and suffix.
              valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
              valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

              // Break the formatted value into the integer “value” part that can be
              // grouped, and fractional or exponential “suffix” part that is not.
              if (maybeSuffix) {
                var i = -1, n = value.length, c;
                while (++i < n) {
                  if (c = value.charCodeAt(i), 48 > c || c > 57) {
                    valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                    value = value.slice(0, i);
                    break;
                  }
                }
              }
            }

            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero) value = group(value, Infinity);

            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length,
                padding = length < width ? new Array(width - length + 1).join(fill) : "";

            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

            // Reconstruct the final output based on the desired alignment.
            switch (align) {
              case "<": return valuePrefix + value + valueSuffix + padding;
              case "=": return valuePrefix + padding + value + valueSuffix;
              case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
            }
            return padding + valuePrefix + value + valueSuffix;
          };
        }

        function formatPrefix(specifier, value) {
          var f = format((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
              e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
              k = Math.pow(10, -e),
              prefix = prefixes[8 + e / 3];
          return function(value) {
            return f(k * value) + prefix;
          };
        }

        return {
          format: format,
          formatPrefix: formatPrefix
        };
      }
      var defaultLocale = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""]
      });

      var caES = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", "\xa0€"]
      });

      var csCZ = locale({
        decimal: ",",
        thousands: "\xa0",
        grouping: [3],
        currency: ["", "\xa0Kč"],
      });

      var deCH = locale({
        decimal: ",",
        thousands: "'",
        grouping: [3],
        currency: ["", "\xa0CHF"]
      });

      var deDE = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", "\xa0€"]
      });

      var enCA = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""]
      });

      var enGB = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["£", ""]
      });

      var esES = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", "\xa0€"]
      });

      var fiFI = locale({
        decimal: ",",
        thousands: "\xa0",
        grouping: [3],
        currency: ["", "\xa0€"]
      });

      var frCA = locale({
        decimal: ",",
        thousands: "\xa0",
        grouping: [3],
        currency: ["", "$"]
      });

      var frFR = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", "\xa0€"]
      });

      var heIL = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["₪", ""]
      });

      var huHU = locale({
        decimal: ",",
        thousands: "\xa0",
        grouping: [3],
        currency: ["", "\xa0Ft"]
      });

      var itIT = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["€", ""]
      });

      var jaJP = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["", "円"]
      });

      var koKR = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["₩", ""]
      });

      var mkMK = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", "\xa0ден."]
      });

      var nlNL = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["€\xa0", ""]
      });

      var plPL = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["", "zł"]
      });

      var ptBR = locale({
        decimal: ",",
        thousands: ".",
        grouping: [3],
        currency: ["R$", ""]
      });

      var ruRU = locale({
        decimal: ",",
        thousands: "\xa0",
        grouping: [3],
        currency: ["", "\xa0руб."]
      });

      var svSE = locale({
        decimal: ",",
        thousands: "\xa0",
        grouping: [3],
        currency: ["", "SEK"]
      });

      var zhCN = locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["¥", ""]
      });

      function precisionFixed(step) {
        return Math.max(0, -exponent(Math.abs(step)));
      }
      function precisionPrefix(step, value) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
      }
      function precisionRound(step, max) {
        step = Math.abs(step), max = Math.abs(max) - step;
        return Math.max(0, exponent(max) - exponent(step)) + 1;
      }
      var format = defaultLocale.format;
      var formatPrefix = defaultLocale.formatPrefix;

      var version = "0.4.2";

      exports.version = version;
      exports.format = format;
      exports.formatPrefix = formatPrefix;
      exports.locale = locale;
      exports.localeCaEs = caES;
      exports.localeCsCz = csCZ;
      exports.localeDeCh = deCH;
      exports.localeDeDe = deDE;
      exports.localeEnCa = enCA;
      exports.localeEnGb = enGB;
      exports.localeEnUs = defaultLocale;
      exports.localeEsEs = esES;
      exports.localeFiFi = fiFI;
      exports.localeFrCa = frCA;
      exports.localeFrFr = frFR;
      exports.localeHeIl = heIL;
      exports.localeHuHu = huHU;
      exports.localeItIt = itIT;
      exports.localeJaJp = jaJP;
      exports.localeKoKr = koKR;
      exports.localeMkMk = mkMK;
      exports.localeNlNl = nlNL;
      exports.localePlPl = plPL;
      exports.localePtBr = ptBR;
      exports.localeRuRu = ruRU;
      exports.localeSvSe = svSE;
      exports.localeZhCn = zhCN;
      exports.formatSpecifier = formatSpecifier;
      exports.precisionFixed = precisionFixed;
      exports.precisionPrefix = precisionPrefix;
      exports.precisionRound = precisionRound;

    }));
    });

    var numberF = d3Format, // defaults to EN-US
        timeF = d3TimeFormat,     // defaults to EN-US
        tmpDate = new Date(2000, 0, 1),
        monthFull, monthAbbr, dayFull, dayAbbr;


    var format = {
      // Update number formatter to use provided locale configuration.
      // For more see https://github.com/d3/d3-format
      numberLocale: numberLocale,
      number:       function(f) { return numberF.format(f); },
      numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },

      // Update time formatter to use provided locale configuration.
      // For more see https://github.com/d3/d3-time-format
      timeLocale:   timeLocale,
      time:         function(f) { return timeF.format(f); },
      utc:          function(f) { return timeF.utcFormat(f); },

      // Set number and time locale simultaneously.
      locale:       function(l) { numberLocale(l); timeLocale(l); },

      // automatic formatting functions
      auto: {
        number:   autoNumberFormat,
        linear:   linearNumberFormat,
        time:     function() { return timeAutoFormat(); },
        utc:      function() { return utcAutoFormat(); }
      },

      month:      monthFormat,      // format month name from integer code
      day:        dayFormat,        // format week day name from integer code
      quarter:    quarterFormat,    // format quarter name from timestamp
      utcQuarter: utcQuarterFormat  // format quarter name from utc timestamp
    };

    // -- Locales ----

    // transform 'en-US' style locale string to match d3-format v0.4+ convention
    function localeRef(l) {
      return l.length > 4 && 'locale' + (
        l[0].toUpperCase() + l[1].toLowerCase() +
        l[3].toUpperCase() + l[4].toLowerCase()
      );
    }

    function numberLocale(l) {
      var f = util.isString(l) ? d3Format[localeRef(l)] : d3Format.locale(l);
      if (f == null) throw Error('Unrecognized locale: ' + l);
      numberF = f;
    }

    function timeLocale(l) {
      var f = util.isString(l) ? d3TimeFormat[localeRef(l)] : d3TimeFormat.locale(l);
      if (f == null) throw Error('Unrecognized locale: ' + l);
      timeF = f;
      monthFull = monthAbbr = dayFull = dayAbbr = null;
    }

    // -- Number Formatting ----

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function linearRange(domain, count) {
      if (!domain.length) domain = [0];
      if (count == null) count = 10;

      var start = domain[0],
          stop = domain[domain.length - 1];

      if (stop < start) { error = stop; stop = start; start = error; }

      var span = (stop - start) || (count = 1, start || stop || 1),
          step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),
          error = span / count / step;

      // Filter ticks to get closer to the desired count.
      if (error >= e10) step *= 10;
      else if (error >= e5) step *= 5;
      else if (error >= e2) step *= 2;

      // Round start and stop values to step interval.
      return [
        Math.ceil(start / step) * step,
        Math.floor(stop / step) * step + step / 2, // inclusive
        step
      ];
    }

    function trimZero(f, decimal) {
      return function(x) {
        var s = f(x),
            n = s.indexOf(decimal);
        if (n < 0) return s;

        var idx = rightmostDigit(s, n),
            end = idx < s.length ? s.slice(idx) : '';

        while (--idx > n) {
          if (s[idx] !== '0') { ++idx; break; }
        }
        return s.slice(0, idx) + end;
      };
    }

    function rightmostDigit(s, n) {
      var i = s.lastIndexOf('e'), c;
      if (i > 0) return i;
      for (i=s.length; --i > n;) {
        c = s.charCodeAt(i);
        if (c >= 48 && c <= 57) return i+1; // is digit
      }
    }

    function autoNumberFormat(f) {
      var decimal = numberF.format('.1f')(1)[1]; // get decimal char
      if (f == null) f = ',';
      f = d3Format.formatSpecifier(f);
      if (f.precision == null) f.precision = 12;
      switch (f.type) {
        case '%': f.precision -= 2; break;
        case 'e': f.precision -= 1; break;
      }
      return trimZero(numberF.format(f), decimal);
    }

    function linearNumberFormat(domain, count, f) {
      var range = linearRange(domain, count);

      if (f == null) f = ',f';

      switch (f = d3Format.formatSpecifier(f), f.type) {
        case 's': {
          var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));
          if (f.precision == null) f.precision = d3Format.precisionPrefix(range[2], value);
          return numberF.formatPrefix(f, value);
        }
        case '':
        case 'e':
        case 'g':
        case 'p':
        case 'r': {
          if (f.precision == null) f.precision = d3Format.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');
          break;
        }
        case 'f':
        case '%': {
          if (f.precision == null) f.precision = d3Format.precisionFixed(range[2]) - 2 * (f.type === '%');
          break;
        }
      }
      return numberF.format(f);
    }

    // -- Datetime Formatting ----

    function timeAutoFormat() {
      var f = timeF.format,
          formatMillisecond = f('.%L'),
          formatSecond = f(':%S'),
          formatMinute = f('%I:%M'),
          formatHour = f('%I %p'),
          formatDay = f('%a %d'),
          formatWeek = f('%b %d'),
          formatMonth = f('%B'),
          formatYear = f('%Y');

      return function(date) {
        var d = +date;
        return (d3Time.second(date) < d ? formatMillisecond
            : d3Time.minute(date) < d ? formatSecond
            : d3Time.hour(date) < d ? formatMinute
            : d3Time.day(date) < d ? formatHour
            : d3Time.month(date) < d ?
              (d3Time.week(date) < d ? formatDay : formatWeek)
            : d3Time.year(date) < d ? formatMonth
            : formatYear)(date);
      };
    }

    function utcAutoFormat() {
      var f = timeF.utcFormat,
          formatMillisecond = f('.%L'),
          formatSecond = f(':%S'),
          formatMinute = f('%I:%M'),
          formatHour = f('%I %p'),
          formatDay = f('%a %d'),
          formatWeek = f('%b %d'),
          formatMonth = f('%B'),
          formatYear = f('%Y');

      return function(date) {
        var d = +date;
        return (d3Time.utcSecond(date) < d ? formatMillisecond
            : d3Time.utcMinute(date) < d ? formatSecond
            : d3Time.utcHour(date) < d ? formatMinute
            : d3Time.utcDay(date) < d ? formatHour
            : d3Time.utcMonth(date) < d ?
              (d3Time.utcWeek(date) < d ? formatDay : formatWeek)
            : d3Time.utcYear(date) < d ? formatMonth
            : formatYear)(date);
      };
    }

    function monthFormat(month, abbreviate) {
      var f = abbreviate ?
        (monthAbbr || (monthAbbr = timeF.format('%b'))) :
        (monthFull || (monthFull = timeF.format('%B')));
      return (tmpDate.setMonth(month), f(tmpDate));
    }

    function dayFormat(day, abbreviate) {
      var f = abbreviate ?
        (dayAbbr || (dayAbbr = timeF.format('%a'))) :
        (dayFull || (dayFull = timeF.format('%A')));
      return (tmpDate.setMonth(0), tmpDate.setDate(2 + day), f(tmpDate));
    }

    function quarterFormat(date) {
      return Math.floor(date.getMonth() / 3) + 1;
    }

    function utcQuarterFormat(date) {
      return Math.floor(date.getUTCMonth() / 3) + 1;
    }

    var timeF$1 = format.time;

    function read$1(data, format$$1) {
      var type = (format$$1 && format$$1.type) || 'json';
      data = formats[type](data, format$$1);
      if (format$$1 && format$$1.parse) parse(data, format$$1.parse);
      return data;
    }

    function parse(data, types) {
      var cols, parsers, d, i, j, clen, len = data.length;

      types = (types==='auto') ? type_1.inferAll(data) : util.duplicate(types);
      cols = util.keys(types);
      parsers = cols.map(function(c) {
        var t = types[c];
        if (t && t.indexOf('date:') === 0) {
          var parts = t.split(/:(.+)?/, 2),  // split on first :
              pattern = parts[1];
          if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
              (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
            pattern = pattern.slice(1, -1);
          } else {
            throw Error('Format pattern must be quoted: ' + pattern);
          }
          pattern = timeF$1(pattern);
          return function(v) { return pattern.parse(v); };
        }
        if (!type_1.parsers[t]) {
          throw Error('Illegal format pattern: ' + c + ':' + t);
        }
        return type_1.parsers[t];
      });

      for (i=0, clen=cols.length; i<len; ++i) {
        d = data[i];
        for (j=0; j<clen; ++j) {
          d[cols[j]] = parsers[j](d[cols[j]]);
        }
      }
      type_1.annotation(data, types);
    }

    read$1.formats = formats;
    var read_1 = read$1;

    var generate = createCommonjsModule(function (module) {
    var gen = module.exports;

    gen.repeat = function(val, n) {
      var a = Array(n), i;
      for (i=0; i<n; ++i) a[i] = val;
      return a;
    };

    gen.zeros = function(n) {
      return gen.repeat(0, n);
    };

    gen.range = function(start, stop, step) {
      if (arguments.length < 3) {
        step = 1;
        if (arguments.length < 2) {
          stop = start;
          start = 0;
        }
      }
      if ((stop - start) / step == Infinity) throw new Error('Infinite range');
      var range = [], i = -1, j;
      if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);
      else while ((j = start + step * ++i) < stop) range.push(j);
      return range;
    };

    gen.random = {};

    gen.random.uniform = function(min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }
      var d = max - min;
      var f = function() {
        return min + d * Math.random();
      };
      f.samples = function(n) {
        return gen.zeros(n).map(f);
      };
      f.pdf = function(x) {
        return (x >= min && x <= max) ? 1/d : 0;
      };
      f.cdf = function(x) {
        return x < min ? 0 : x > max ? 1 : (x - min) / d;
      };
      f.icdf = function(p) {
        return (p >= 0 && p <= 1) ? min + p*d : NaN;
      };
      return f;
    };

    gen.random.integer = function(a, b) {
      if (b === undefined) {
        b = a;
        a = 0;
      }
      var d = b - a;
      var f = function() {
        return a + Math.floor(d * Math.random());
      };
      f.samples = function(n) {
        return gen.zeros(n).map(f);
      };
      f.pdf = function(x) {
        return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;
      };
      f.cdf = function(x) {
        var v = Math.floor(x);
        return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
      };
      f.icdf = function(p) {
        return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;
      };
      return f;
    };

    gen.random.normal = function(mean, stdev) {
      mean = mean || 0;
      stdev = stdev || 1;
      var next;
      var f = function() {
        var x = 0, y = 0, rds, c;
        if (next !== undefined) {
          x = next;
          next = undefined;
          return x;
        }
        do {
          x = Math.random()*2-1;
          y = Math.random()*2-1;
          rds = x*x + y*y;
        } while (rds === 0 || rds > 1);
        c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform
        next = mean + y*c*stdev;
        return mean + x*c*stdev;
      };
      f.samples = function(n) {
        return gen.zeros(n).map(f);
      };
      f.pdf = function(x) {
        var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));
        return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;
      };
      f.cdf = function(x) {
        // Approximation from West (2009)
        // Better Approximations to Cumulative Normal Functions
        var cd,
            z = (x - mean) / stdev,
            Z = Math.abs(z);
        if (Z > 37) {
          cd = 0;
        } else {
          var sum, exp = Math.exp(-Z*Z/2);
          if (Z < 7.07106781186547) {
            sum = 3.52624965998911e-02 * Z + 0.700383064443688;
            sum = sum * Z + 6.37396220353165;
            sum = sum * Z + 33.912866078383;
            sum = sum * Z + 112.079291497871;
            sum = sum * Z + 221.213596169931;
            sum = sum * Z + 220.206867912376;
            cd = exp * sum;
            sum = 8.83883476483184e-02 * Z + 1.75566716318264;
            sum = sum * Z + 16.064177579207;
            sum = sum * Z + 86.7807322029461;
            sum = sum * Z + 296.564248779674;
            sum = sum * Z + 637.333633378831;
            sum = sum * Z + 793.826512519948;
            sum = sum * Z + 440.413735824752;
            cd = cd / sum;
          } else {
            sum = Z + 0.65;
            sum = Z + 4 / sum;
            sum = Z + 3 / sum;
            sum = Z + 2 / sum;
            sum = Z + 1 / sum;
            cd = exp / sum / 2.506628274631;
          }
        }
        return z > 0 ? 1 - cd : cd;
      };
      f.icdf = function(p) {
        // Approximation of Probit function using inverse error function.
        if (p <= 0 || p >= 1) return NaN;
        var x = 2*p - 1,
            v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),
            a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),
            b = Math.log(1 - (x*x)) / v,
            s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);
        return mean + stdev * Math.SQRT2 * s;
      };
      return f;
    };

    gen.random.bootstrap = function(domain, smooth) {
      // Generates a bootstrap sample from a set of observations.
      // Smooth bootstrapping adds random zero-centered noise to the samples.
      var val = domain.filter(util.isValid),
          len = val.length,
          err = smooth ? gen.random.normal(0, smooth) : null;
      var f = function() {
        return val[~~(Math.random()*len)] + (err ? err() : 0);
      };
      f.samples = function(n) {
        return gen.zeros(n).map(f);
      };
      return f;
    };
    });

    var stats_1 = createCommonjsModule(function (module) {
    var stats = module.exports;

    // Collect unique values.
    // Output: an array of unique values, in first-observed order
    stats.unique = function(values, f, results) {
      f = util.$(f);
      results = results || [];
      var u = {}, v, i, n;
      for (i=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (v in u) continue;
        u[v] = 1;
        results.push(v);
      }
      return results;
    };

    // Return the length of the input array.
    stats.count = function(values) {
      return values && values.length || 0;
    };

    // Count the number of non-null, non-undefined, non-NaN values.
    stats.count.valid = function(values, f) {
      f = util.$(f);
      var v, i, n, valid = 0;
      for (i=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) valid += 1;
      }
      return valid;
    };

    // Count the number of null or undefined values.
    stats.count.missing = function(values, f) {
      f = util.$(f);
      var v, i, n, count = 0;
      for (i=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (v == null) count += 1;
      }
      return count;
    };

    // Count the number of distinct values.
    // Null, undefined and NaN are each considered distinct values.
    stats.count.distinct = function(values, f) {
      f = util.$(f);
      var u = {}, v, i, n, count = 0;
      for (i=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (v in u) continue;
        u[v] = 1;
        count += 1;
      }
      return count;
    };

    // Construct a map from distinct values to occurrence counts.
    stats.count.map = function(values, f) {
      f = util.$(f);
      var map = {}, v, i, n;
      for (i=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        map[v] = (v in map) ? map[v] + 1 : 1;
      }
      return map;
    };

    // Compute the median of an array of numbers.
    stats.median = function(values, f) {
      if (f) values = values.map(util.$(f));
      values = values.filter(util.isValid).sort(util.cmp);
      return stats.quantile(values, 0.5);
    };

    // Computes the quartile boundaries of an array of numbers.
    stats.quartile = function(values, f) {
      if (f) values = values.map(util.$(f));
      values = values.filter(util.isValid).sort(util.cmp);
      var q = stats.quantile;
      return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];
    };

    // Compute the quantile of a sorted array of numbers.
    // Adapted from the D3.js implementation.
    stats.quantile = function(values, f, p) {
      if (p === undefined) { p = f; f = util.identity; }
      f = util.$(f);
      var H = (values.length - 1) * p + 1,
          h = Math.floor(H),
          v = +f(values[h - 1]),
          e = H - h;
      return e ? v + e * (f(values[h]) - v) : v;
    };

    // Compute the sum of an array of numbers.
    stats.sum = function(values, f) {
      f = util.$(f);
      for (var sum=0, i=0, n=values.length, v; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) sum += v;
      }
      return sum;
    };

    // Compute the mean (average) of an array of numbers.
    stats.mean = function(values, f) {
      f = util.$(f);
      var mean = 0, delta, i, n, c, v;
      for (i=0, c=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) {
          delta = v - mean;
          mean = mean + delta / (++c);
        }
      }
      return mean;
    };

    // Compute the geometric mean of an array of numbers.
    stats.mean.geometric = function(values, f) {
      f = util.$(f);
      var mean = 1, c, n, v, i;
      for (i=0, c=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) {
          if (v <= 0) {
            throw Error("Geometric mean only defined for positive values.");
          }
          mean *= v;
          ++c;
        }
      }
      mean = c > 0 ? Math.pow(mean, 1/c) : 0;
      return mean;
    };

    // Compute the harmonic mean of an array of numbers.
    stats.mean.harmonic = function(values, f) {
      f = util.$(f);
      var mean = 0, c, n, v, i;
      for (i=0, c=0, n=values.length; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) {
          mean += 1/v;
          ++c;
        }
      }
      return c / mean;
    };

    // Compute the sample variance of an array of numbers.
    stats.variance = function(values, f) {
      f = util.$(f);
      if (!util.isArray(values) || values.length < 2) return 0;
      var mean = 0, M2 = 0, delta, i, c, v;
      for (i=0, c=0; i<values.length; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) {
          delta = v - mean;
          mean = mean + delta / (++c);
          M2 = M2 + delta * (v - mean);
        }
      }
      M2 = M2 / (c - 1);
      return M2;
    };

    // Compute the sample standard deviation of an array of numbers.
    stats.stdev = function(values, f) {
      return Math.sqrt(stats.variance(values, f));
    };

    // Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.
    stats.modeskew = function(values, f) {
      var avg = stats.mean(values, f),
          med = stats.median(values, f),
          std = stats.stdev(values, f);
      return std === 0 ? 0 : (avg - med) / std;
    };

    // Find the minimum value in an array.
    stats.min = function(values, f) {
      return stats.extent(values, f)[0];
    };

    // Find the maximum value in an array.
    stats.max = function(values, f) {
      return stats.extent(values, f)[1];
    };

    // Find the minimum and maximum of an array of values.
    stats.extent = function(values, f) {
      f = util.$(f);
      var a, b, v, i, n = values.length;
      for (i=0; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) { a = b = v; break; }
      }
      for (; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) {
          if (v < a) a = v;
          if (v > b) b = v;
        }
      }
      return [a, b];
    };

    // Find the integer indices of the minimum and maximum values.
    stats.extent.index = function(values, f) {
      f = util.$(f);
      var x = -1, y = -1, a, b, v, i, n = values.length;
      for (i=0; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) { a = b = v; x = y = i; break; }
      }
      for (; i<n; ++i) {
        v = f ? f(values[i]) : values[i];
        if (util.isValid(v)) {
          if (v < a) { a = v; x = i; }
          if (v > b) { b = v; y = i; }
        }
      }
      return [x, y];
    };

    // Compute the dot product of two arrays of numbers.
    stats.dot = function(values, a, b) {
      var sum = 0, i, v;
      if (!b) {
        if (values.length !== a.length) {
          throw Error('Array lengths must match.');
        }
        for (i=0; i<values.length; ++i) {
          v = values[i] * a[i];
          if (v === v) sum += v;
        }
      } else {
        a = util.$(a);
        b = util.$(b);
        for (i=0; i<values.length; ++i) {
          v = a(values[i]) * b(values[i]);
          if (v === v) sum += v;
        }
      }
      return sum;
    };

    // Compute the vector distance between two arrays of numbers.
    // Default is Euclidean (exp=2) distance, configurable via exp argument.
    stats.dist = function(values, a, b, exp) {
      var f = util.isFunction(b) || util.isString(b),
          X = values,
          Y = f ? values : a,
          e = f ? exp : b,
          L2 = e === 2 || e == null,
          n = values.length, s = 0, d, i;
      if (f) {
        a = util.$(a);
        b = util.$(b);
      }
      for (i=0; i<n; ++i) {
        d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);
        s += L2 ? d*d : Math.pow(Math.abs(d), e);
      }
      return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);
    };

    // Compute the Cohen's d effect size between two arrays of numbers.
    stats.cohensd = function(values, a, b) {
      var X = b ? values.map(util.$(a)) : values,
          Y = b ? values.map(util.$(b)) : a,
          x1 = stats.mean(X),
          x2 = stats.mean(Y),
          n1 = stats.count.valid(X),
          n2 = stats.count.valid(Y);

      if ((n1+n2-2) <= 0) {
        // if both arrays are size 1, or one is empty, there's no effect size
        return 0;
      }
      // pool standard deviation
      var s1 = stats.variance(X),
          s2 = stats.variance(Y),
          s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));
      // if there is no variance, there's no effect size
      return s===0 ? 0 : (x1 - x2) / s;
    };

    // Computes the covariance between two arrays of numbers
    stats.covariance = function(values, a, b) {
      var X = b ? values.map(util.$(a)) : values,
          Y = b ? values.map(util.$(b)) : a,
          n = X.length,
          xm = stats.mean(X),
          ym = stats.mean(Y),
          sum = 0, c = 0, i, x, y, vx, vy;

      if (n !== Y.length) {
        throw Error('Input lengths must match.');
      }

      for (i=0; i<n; ++i) {
        x = X[i]; vx = util.isValid(x);
        y = Y[i]; vy = util.isValid(y);
        if (vx && vy) {
          sum += (x-xm) * (y-ym);
          ++c;
        } else if (vx || vy) {
          throw Error('Valid values must align.');
        }
      }
      return sum / (c-1);
    };

    // Compute ascending rank scores for an array of values.
    // Ties are assigned their collective mean rank.
    stats.rank = function(values, f) {
      f = util.$(f) || util.identity;
      var a = values.map(function(v, i) {
          return {idx: i, val: f(v)};
        })
        .sort(util.comparator('val'));

      var n = values.length,
          r = Array(n),
          tie = -1, p = {}, i, v, mu;

      for (i=0; i<n; ++i) {
        v = a[i].val;
        if (tie < 0 && p === v) {
          tie = i - 1;
        } else if (tie > -1 && p !== v) {
          mu = 1 + (i-1 + tie) / 2;
          for (; tie<i; ++tie) r[a[tie].idx] = mu;
          tie = -1;
        }
        r[a[i].idx] = i + 1;
        p = v;
      }

      if (tie > -1) {
        mu = 1 + (n-1 + tie) / 2;
        for (; tie<n; ++tie) r[a[tie].idx] = mu;
      }

      return r;
    };

    // Compute the sample Pearson product-moment correlation of two arrays of numbers.
    stats.cor = function(values, a, b) {
      var fn = b;
      b = fn ? values.map(util.$(b)) : a;
      a = fn ? values.map(util.$(a)) : values;

      var dot = stats.dot(a, b),
          mua = stats.mean(a),
          mub = stats.mean(b),
          sda = stats.stdev(a),
          sdb = stats.stdev(b),
          n = values.length;

      return (dot - n*mua*mub) / ((n-1) * sda * sdb);
    };

    // Compute the Spearman rank correlation of two arrays of values.
    stats.cor.rank = function(values, a, b) {
      var ra = b ? stats.rank(values, a) : stats.rank(values),
          rb = b ? stats.rank(values, b) : stats.rank(a),
          n = values.length, i, s, d;

      for (i=0, s=0; i<n; ++i) {
        d = ra[i] - rb[i];
        s += d * d;
      }

      return 1 - 6*s / (n * (n*n-1));
    };

    // Compute the distance correlation of two arrays of numbers.
    // http://en.wikipedia.org/wiki/Distance_correlation
    stats.cor.dist = function(values, a, b) {
      var X = b ? values.map(util.$(a)) : values,
          Y = b ? values.map(util.$(b)) : a;

      var A = stats.dist.mat(X),
          B = stats.dist.mat(Y),
          n = A.length,
          i, aa, bb, ab;

      for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {
        aa += A[i]*A[i];
        bb += B[i]*B[i];
        ab += A[i]*B[i];
      }

      return Math.sqrt(ab / Math.sqrt(aa*bb));
    };

    // Simple linear regression.
    // Returns a "fit" object with slope (m), intercept (b),
    // r value (R), and sum-squared residual error (rss).
    stats.linearRegression = function(values, a, b) {
      var X = b ? values.map(util.$(a)) : values,
          Y = b ? values.map(util.$(b)) : a,
          n = X.length,
          xy = stats.covariance(X, Y), // will throw err if valid vals don't align
          sx = stats.stdev(X),
          sy = stats.stdev(Y),
          slope = xy / (sx*sx),
          icept = stats.mean(Y) - slope * stats.mean(X),
          fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},
          res, i;

      for (i=0; i<n; ++i) {
        if (util.isValid(X[i]) && util.isValid(Y[i])) {
          res = (slope*X[i] + icept) - Y[i];
          fit.rss += res * res;
        }
      }

      return fit;
    };

    // Namespace for bootstrap
    stats.bootstrap = {};

    // Construct a bootstrapped confidence interval at a given percentile level
    // Arguments are an array, an optional n (defaults to 1000),
    //  an optional alpha (defaults to 0.05), and an optional smoothing parameter
    stats.bootstrap.ci = function(values, a, b, c, d) {
      var X, N, alpha, smooth, bs, means, i;
      if (util.isFunction(a) || util.isString(a)) {
        X = values.map(util.$(a));
        N = b;
        alpha = c;
        smooth = d;
      } else {
        X = values;
        N = a;
        alpha = b;
        smooth = c;
      }
      N = N ? +N : 1000;
      alpha = alpha || 0.05;

      bs = generate.random.bootstrap(X, smooth);
      for (i=0, means = Array(N); i<N; ++i) {
        means[i] = stats.mean(bs.samples(X.length));
      }
      means.sort(util.numcmp);
      return [
        stats.quantile(means, alpha/2),
        stats.quantile(means, 1-(alpha/2))
      ];
    };

    // Namespace for z-tests
    stats.z = {};

    // Construct a z-confidence interval at a given significance level
    // Arguments are an array and an optional alpha (defaults to 0.05).
    stats.z.ci = function(values, a, b) {
      var X = values, alpha = a;
      if (util.isFunction(a) || util.isString(a)) {
        X = values.map(util.$(a));
        alpha = b;
      }
      alpha = alpha || 0.05;

      var z = alpha===0.05 ? 1.96 : generate.random.normal(0, 1).icdf(1-(alpha/2)),
          mu = stats.mean(X),
          SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));
      return [mu - (z*SE), mu + (z*SE)];
    };

    // Perform a z-test of means. Returns the p-value.
    // If a single array is provided, performs a one-sample location test.
    // If two arrays or a table and two accessors are provided, performs
    // a two-sample location test. A paired test is performed if specified
    // by the options hash.
    // The options hash format is: {paired: boolean, nullh: number}.
    // http://en.wikipedia.org/wiki/Z-test
    // http://en.wikipedia.org/wiki/Paired_difference_test
    stats.z.test = function(values, a, b, opt) {
      if (util.isFunction(b) || util.isString(b)) { // table and accessors
        return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);
      } else if (util.isArray(a)) { // two arrays
        return (b && b.paired ? ztestP : ztest2)(b, values, a);
      } else if (util.isFunction(a) || util.isString(a)) {
        return ztest1(b, values, a); // table and accessor
      } else {
        return ztest1(a, values); // one array
      }
    };

    // Perform a z-test of means. Returns the p-value.
    // Assuming we have a list of values, and a null hypothesis. If no null
    // hypothesis, assume our null hypothesis is mu=0.
    function ztest1(opt, X, f) {
      var nullH = opt && opt.nullh || 0,
          gaussian = generate.random.normal(0, 1),
          mu = stats.mean(X,f),
          SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));

      if (SE===0) {
        // Test not well defined when standard error is 0.
        return (mu - nullH) === 0 ? 1 : 0;
      }
      // Two-sided, so twice the one-sided cdf.
      var z = (mu - nullH) / SE;
      return 2 * gaussian.cdf(-Math.abs(z));
    }

    // Perform a two sample paired z-test of means. Returns the p-value.
    function ztestP(opt, values, a, b) {
      var X = b ? values.map(util.$(a)) : values,
          Y = b ? values.map(util.$(b)) : a,
          n1 = stats.count(X),
          n2 = stats.count(Y),
          diffs = Array(), i;

      if (n1 !== n2) {
        throw Error('Array lengths must match.');
      }
      for (i=0; i<n1; ++i) {
        // Only valid differences should contribute to the test statistic
        if (util.isValid(X[i]) && util.isValid(Y[i])) {
          diffs.push(X[i] - Y[i]);
        }
      }
      return stats.z.test(diffs, opt && opt.nullh || 0);
    }

    // Perform a two sample z-test of means. Returns the p-value.
    function ztest2(opt, values, a, b) {
      var X = b ? values.map(util.$(a)) : values,
          Y = b ? values.map(util.$(b)) : a,
          n1 = stats.count.valid(X),
          n2 = stats.count.valid(Y),
          gaussian = generate.random.normal(0, 1),
          meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),
          SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);

      if (SE===0) {
        // Not well defined when pooled standard error is 0.
        return meanDiff===0 ? 1 : 0;
      }
      // Two-tailed, so twice the one-sided cdf.
      var z = meanDiff / SE;
      return 2 * gaussian.cdf(-Math.abs(z));
    }

    // Construct a mean-centered distance matrix for an array of numbers.
    stats.dist.mat = function(X) {
      var n = X.length,
          m = n*n,
          A = Array(m),
          R = generate.zeros(n),
          M = 0, v, i, j;

      for (i=0; i<n; ++i) {
        A[i*n+i] = 0;
        for (j=i+1; j<n; ++j) {
          A[i*n+j] = (v = Math.abs(X[i] - X[j]));
          A[j*n+i] = v;
          R[i] += v;
          R[j] += v;
        }
      }

      for (i=0; i<n; ++i) {
        M += R[i];
        R[i] /= n;
      }
      M /= m;

      for (i=0; i<n; ++i) {
        for (j=i; j<n; ++j) {
          A[i*n+j] += M - R[i] - R[j];
          A[j*n+i] = A[i*n+j];
        }
      }

      return A;
    };

    // Compute the Shannon entropy (log base 2) of an array of counts.
    stats.entropy = function(counts, f) {
      f = util.$(f);
      var i, p, s = 0, H = 0, n = counts.length;
      for (i=0; i<n; ++i) {
        s += (f ? f(counts[i]) : counts[i]);
      }
      if (s === 0) return 0;
      for (i=0; i<n; ++i) {
        p = (f ? f(counts[i]) : counts[i]) / s;
        if (p) H += p * Math.log(p);
      }
      return -H / Math.LN2;
    };

    // Compute the mutual information between two discrete variables.
    // Returns an array of the form [MI, MI_distance]
    // MI_distance is defined as 1 - I(a,b) / H(a,b).
    // http://en.wikipedia.org/wiki/Mutual_information
    stats.mutual = function(values, a, b, counts) {
      var x = counts ? values.map(util.$(a)) : values,
          y = counts ? values.map(util.$(b)) : a,
          z = counts ? values.map(util.$(counts)) : b;

      var px = {},
          py = {},
          n = z.length,
          s = 0, I = 0, H = 0, p, t, i;

      for (i=0; i<n; ++i) {
        px[x[i]] = 0;
        py[y[i]] = 0;
      }

      for (i=0; i<n; ++i) {
        px[x[i]] += z[i];
        py[y[i]] += z[i];
        s += z[i];
      }

      t = 1 / (s * Math.LN2);
      for (i=0; i<n; ++i) {
        if (z[i] === 0) continue;
        p = (s * z[i]) / (px[x[i]] * py[y[i]]);
        I += z[i] * t * Math.log(p);
        H += z[i] * t * Math.log(z[i]/s);
      }

      return [I, 1 + I/H];
    };

    // Compute the mutual information between two discrete variables.
    stats.mutual.info = function(values, a, b, counts) {
      return stats.mutual(values, a, b, counts)[0];
    };

    // Compute the mutual information distance between two discrete variables.
    // MI_distance is defined as 1 - I(a,b) / H(a,b).
    stats.mutual.dist = function(values, a, b, counts) {
      return stats.mutual(values, a, b, counts)[1];
    };

    // Compute a profile of summary statistics for a variable.
    stats.profile = function(values, f) {
      var mean = 0,
          valid = 0,
          missing = 0,
          distinct = 0,
          min = null,
          max = null,
          M2 = 0,
          vals = [],
          u = {}, delta, sd, i, v, x;

      // compute summary stats
      for (i=0; i<values.length; ++i) {
        v = f ? f(values[i]) : values[i];

        // update unique values
        u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);

        if (v == null) {
          ++missing;
        } else if (util.isValid(v)) {
          // update stats
          x = (typeof v === 'string') ? v.length : v;
          if (min===null || x < min) min = x;
          if (max===null || x > max) max = x;
          delta = x - mean;
          mean = mean + delta / (++valid);
          M2 = M2 + delta * (x - mean);
          vals.push(x);
        }
      }
      M2 = M2 / (valid - 1);
      sd = Math.sqrt(M2);

      // sort values for median and iqr
      vals.sort(util.cmp);

      return {
        type:     type_1(values, f),
        unique:   u,
        count:    values.length,
        valid:    valid,
        missing:  missing,
        distinct: distinct,
        min:      min,
        max:      max,
        mean:     mean,
        stdev:    sd,
        median:   (v = stats.quantile(vals, 0.5)),
        q1:       stats.quantile(vals, 0.25),
        q3:       stats.quantile(vals, 0.75),
        modeskew: sd === 0 ? 0 : (mean - v) / sd
      };
    };

    // Compute profiles for all variables in a data set.
    stats.summary = function(data, fields) {
      fields = fields || util.keys(data[0]);
      var s = fields.map(function(f) {
        var p = stats.profile(data, util.$(f));
        return (p.field = f, p);
      });
      return (s.__summary__ = true, s);
    };
    });

    function data2schema(data) {
        const readData = read_1(data);
        const summary = stats_1.summary(readData);
        const keyedSummary = {};
        summary.forEach((column) => {
            const field = column.field;
            delete column.field;
            keyedSummary[field] = column;
        });
        return {
            stats: keyedSummary,
            size: data.length,
        };
    }

    function json2constraints(json) {
        const type = json[0].type;
        json.forEach(constraint => {
            if (constraint.type !== type) {
                throw new Error(`constraints not all of type ${type}`);
            }
        });
        let definitions = '';
        let weights;
        let assigns;
        if (type === 'soft') {
            weights = '';
            assigns = '';
        }
        for (const constraint of json) {
            const def = `% @constraint ${constraint.description}
${constraint.asp}`;
            definitions += def;
            definitions += '\n\n';
            if (type === 'soft') {
                const weight = `#const ${constraint.name}_weight = ${constraint.weight}.`;
                weights += weight;
                weights += '\n';
                const assign = `soft_weight(${constraint.name}, ${constraint.name}_weight).`;
                assigns += assign;
                assigns += '\n';
            }
        }
        if (type === 'hard') {
            return { definitions };
        }
        else {
            return {
                definitions,
                weights,
                assigns,
            };
        }
    }

    function schema2asp(schema) {
        if (!schema) {
            throw Error('No data has been prepared');
        }
        const stats = schema.stats;
        const decl = [`num_rows(${schema.size}).\n`];
        Object.keys(stats).forEach((field, i) => {
            const fieldName = `\"${field}\"`;
            const fieldStats = stats[field];
            const fieldType = `fieldtype(${fieldName},${fieldStats.type}).`;
            const cardinality = `cardinality(${fieldName}, ${fieldStats.distinct}).`;
            decl.push(`${fieldType}\n${cardinality}`);
        });
        return decl;
    }

    /**
     * Convert from Vega-Lite to ASP.
     */
    function vl2asp(spec) {
        const facts = [`mark(${spec.mark}).`];
        if ('data' in spec && 'url' in spec.data) {
            facts.push(`data("${spec.data.url}").`);
        }
        const encoding = spec.encoding || {};
        let i = 0;
        for (const channel of Object.keys(encoding)) {
            const eid = `e${i++}`;
            facts.push(`encoding(${eid}).`);
            facts.push(`channel(${eid},${channel}).`);
            let encFieldType = null;
            let encZero = null;
            let encBinned = null;
            // translate encodings
            for (const field of Object.keys(encoding[channel])) {
                const fieldContent = encoding[channel][field];
                if (field === 'type') {
                    encFieldType = fieldContent;
                }
                if (field === 'bin') {
                    encBinned = fieldContent;
                }
                if (field === 'scale') {
                    // translate two boolean fields
                    if ('zero' in fieldContent) {
                        encZero = fieldContent.zero;
                        if (fieldContent.zero) {
                            facts.push(`zero(${eid}).`);
                        }
                        else {
                            facts.push(`:- zero(${eid}).`);
                        }
                    }
                    if ('log' in fieldContent) {
                        if (fieldContent.log) {
                            facts.push(`log(${eid}).`);
                        }
                        else {
                            facts.push(`:-log(${eid}).`);
                        }
                    }
                }
                else if (field === 'bin') {
                    if (fieldContent.maxbins) {
                        facts.push(`${field}(${eid},${fieldContent.maxbins}).`);
                    }
                    else {
                        facts.push(`${field}(${eid},10).`);
                    }
                }
                else if (field === 'field') {
                    // fields can have spaces and start with capital letters
                    facts.push(`${field}(${eid},"${fieldContent}").`);
                }
                else {
                    // translate normal fields
                    if (field !== 'bin') {
                        facts.push(`${field}(${eid},${fieldContent}).`);
                    }
                }
            }
            if (encFieldType === 'quantitative' && encZero === null && encBinned === null) {
                facts.push(`zero(${eid}).`);
            }
        }
        return facts;
    }

    var empty = {};

    var empty$1 = /*#__PURE__*/Object.freeze({
        default: empty
    });

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    }

    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };

    // path.resolve([from ...], to)
    // posix version
    function resolve() {
      var resolvedPath = '',
          resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : '/';

        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }

      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)

      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');

      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    }
    // path.normalize(path)
    // posix version
    function normalize(path) {
      var isPathAbsolute = isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';

      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isPathAbsolute).join('/');

      if (!path && !isPathAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }

      return (isPathAbsolute ? '/' : '') + path;
    }
    // posix version
    function isAbsolute(path) {
      return path.charAt(0) === '/';
    }

    // posix version
    function join() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return normalize(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    }


    // path.relative(from, to)
    // posix version
    function relative(from, to) {
      from = resolve(from).substr(1);
      to = resolve(to).substr(1);

      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }

        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }

        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }

      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));

      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }

      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }

      outputParts = outputParts.concat(toParts.slice(samePartsLength));

      return outputParts.join('/');
    }

    var sep = '/';
    var delimiter = ':';

    function dirname(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];

      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }

      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }

      return root + dir;
    }

    function basename(path, ext) {
      var f = splitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    }


    function extname(path) {
      return splitPath(path)[3];
    }
    var path$1 = {
      extname: extname,
      basename: basename,
      dirname: dirname,
      sep: sep,
      delimiter: delimiter,
      relative: relative,
      join: join,
      isAbsolute: isAbsolute,
      normalize: normalize,
      resolve: resolve
    };
    function filter (xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
    }

    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b' ?
        function (str, start, len) { return str.substr(start, len) } :
        function (str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
        }
    ;

    var path$2 = /*#__PURE__*/Object.freeze({
        resolve: resolve,
        normalize: normalize,
        isAbsolute: isAbsolute,
        join: join,
        relative: relative,
        sep: sep,
        delimiter: delimiter,
        dirname: dirname,
        basename: basename,
        extname: extname,
        default: path$1
    });

    var require$$0 = ( empty$1 && empty ) || empty$1;

    var require$$1 = ( path$2 && path$1 ) || path$2;

    var clingo = createCommonjsModule(function (module, exports) {
    var Module = (function() {
      var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
      return (
    function(Module) {
      Module = Module || {};

    var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}Module["arguments"]=[];Module["thisProgram"]="./this.program";Module["quit"]=(function(status,toThrow){throw toThrow});Module["preRun"]=[];Module["postRun"]=[];var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof commonjsRequire==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}else{return scriptDirectory+path}}if(ENVIRONMENT_IS_NODE){scriptDirectory=__dirname+"/";var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;if(!nodeFS)nodeFS=require$$0;if(!nodePath)nodePath=require$$1;filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename);return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}assert(ret.buffer);return ret};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/");}Module["arguments"]=process["argv"].slice(2);process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));process["on"]("unhandledRejection",(function(reason,p){process["exit"](1);}));Module["quit"]=(function(status){process["exit"](status);});Module["inspect"]=(function(){return "[Emscripten Module object]"});}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){Module["read"]=function shell_read(f){return read(f)};}Module["readBinary"]=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs;}else if(typeof arguments!="undefined"){Module["arguments"]=arguments;}if(typeof quit==="function"){Module["quit"]=(function(status){quit(status);});}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WEB){if(document.currentScript){scriptDirectory=document.currentScript.src;}}else{scriptDirectory=self.location.href;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else{scriptDirectory="";}Module["read"]=function shell_read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)};}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror();};xhr.onerror=onerror;xhr.send(null);};Module["setWindowTitle"]=(function(title){document.title=title;});}var out=Module["print"]||(typeof console!=="undefined"?console.log.bind(console):typeof print!=="undefined"?print:null);var err=Module["printErr"]||(typeof printErr!=="undefined"?printErr:typeof console!=="undefined"&&console.warn.bind(console)||out);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=undefined;var STACK_ALIGN=16;function staticAlloc(size){var ret=STATICTOP;STATICTOP=STATICTOP+size+15&-16;return ret}function dynamicAlloc(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=ret+size+15&-16;HEAP32[DYNAMICTOP_PTR>>2]=end;if(end>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){HEAP32[DYNAMICTOP_PTR>>2]=ret;return 0}}return ret}function alignMemory(size,factor){if(!factor)factor=STACK_ALIGN;var ret=size=Math.ceil(size/factor)*factor;return ret}function getNativeTypeSize(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return 4}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}var asm2wasmImports={"f64-rem":(function(x,y){return x%y}),"debugger":(function(){debugger})};var GLOBAL_BASE=1024;var ABORT=false;function assert(condition,text){if(!condition){abort("Assertion failed: "+text);}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){stackSave();}),"stackRestore":(function(){stackRestore();}),"arrayToC":(function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len);}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){function convertReturnValue(ret){if(returnType==="string")return Pointer_stringify(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i]);}else{cArgs[i]=args[i];}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type);}}var ALLOC_NORMAL=0;var ALLOC_STATIC=2;var ALLOC_NONE=4;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab;}else{zeroinit=false;size=slab.length;}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr;}else{ret=[typeof _malloc==="function"?_malloc:staticAlloc,stackAlloc,staticAlloc,dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length));}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0;}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0;}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret);}else{HEAPU8.set(new Uint8Array(slab),ret);}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=getNativeTypeSize(type);previousType=type;}i+=typeSize;}return ret}function getMemory(size){if(!staticSealed)return staticAlloc(size);if(!runtimeInitialized)return dynamicAlloc(size);return _malloc(size)}function Pointer_stringify(ptr,length){if(length===0||!ptr)return "";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK;}return ret}return UTF8ToString(ptr)}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3;}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4;}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5;}}}if(u0<65536){str+=String.fromCharCode(u0);}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}}function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len;}else if(u<=2047){len+=2;}else if(u<=65535){len+=3;}else if(u<=2097151){len+=4;}else if(u<=67108863){len+=5;}else{len+=6;}}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function demangle(func){return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e;}if(!err.stack){return "(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}var WASM_PAGE_SIZE=65536;var ASMJS_PAGE_SIZE=16777216;var MIN_TOTAL_MEMORY=16777216;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBuffer(buf){Module["buffer"]=buffer=buf;}function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer);}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");}if(!Module["reallocBuffer"])Module["reallocBuffer"]=(function(size){var ret;try{var oldHEAP8=HEAP8;ret=new ArrayBuffer(size);var temp=new Int8Array(ret);temp.set(oldHEAP8);}catch(e){return false}var success=_emscripten_replace_memory(ret);if(!success)return false;return ret});function enlargeMemory(){var PAGE_MULTIPLE=Module["usingWasm"]?WASM_PAGE_SIZE:ASMJS_PAGE_SIZE;var LIMIT=2147483648-PAGE_MULTIPLE;if(HEAP32[DYNAMICTOP_PTR>>2]>LIMIT){return false}var OLD_TOTAL_MEMORY=TOTAL_MEMORY;TOTAL_MEMORY=Math.max(TOTAL_MEMORY,MIN_TOTAL_MEMORY);while(TOTAL_MEMORY<HEAP32[DYNAMICTOP_PTR>>2]){if(TOTAL_MEMORY<=536870912){TOTAL_MEMORY=alignUp(2*TOTAL_MEMORY,PAGE_MULTIPLE);}else{TOTAL_MEMORY=Math.min(alignUp((3*TOTAL_MEMORY+2147483648)/4,PAGE_MULTIPLE),LIMIT);}}var replacement=Module["reallocBuffer"](TOTAL_MEMORY);if(!replacement||replacement.byteLength!=TOTAL_MEMORY){TOTAL_MEMORY=OLD_TOTAL_MEMORY;return false}updateGlobalBuffer(replacement);updateGlobalBufferViews();return true}var byteLength;try{byteLength=Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype,"byteLength").get);byteLength(new ArrayBuffer(4));}catch(e){byteLength=(function(buffer){return buffer.byteLength});}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)err("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"];}else{if(typeof WebAssembly==="object"&&typeof WebAssembly.Memory==="function"){Module["wasmMemory"]=new WebAssembly.Memory({"initial":TOTAL_MEMORY/WASM_PAGE_SIZE});buffer=Module["wasmMemory"].buffer;}else{buffer=new ArrayBuffer(TOTAL_MEMORY);}Module["buffer"]=buffer;}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else{Module["dynCall_vi"](func,callback.arg);}}else{func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer);}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i);}if(!dontAddNull)HEAP8[buffer>>0]=0;}var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null;}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}function integrateWasmJS(){var wasmTextFile="clingo.wast";var wasmBinaryFile="clingo.wasm";var asmjsCodeFile="clingo.temp.asm.js";if(!isDataURI(wasmTextFile)){wasmTextFile=locateFile(wasmTextFile);}if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}if(!isDataURI(asmjsCodeFile)){asmjsCodeFile=locateFile(asmjsCodeFile);}var wasmPageSize=64*1024;var info={"global":null,"env":null,"asm2wasm":asm2wasmImports,"parent":Module};var exports=null;function mergeMemory(newBuffer){var oldBuffer=Module["buffer"];if(newBuffer.byteLength<oldBuffer.byteLength){err("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");}var oldView=new Int8Array(oldBuffer);var newView=new Int8Array(newBuffer);newView.set(oldView);updateGlobalBuffer(newBuffer);updateGlobalBufferViews();}function fixImports(imports){return imports}function getBinary(){try{if(Module["wasmBinary"]){return new Uint8Array(Module["wasmBinary"])}if(Module["readBinary"]){return Module["readBinary"](wasmBinaryFile)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!Module["wasmBinary"]&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then((function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()})).catch((function(){return getBinary()}))}return new Promise((function(resolve,reject){resolve(getBinary());}))}function doNativeWasm(global,env,providedBuffer){if(typeof WebAssembly!=="object"){err("no native wasm support detected");return false}if(!(Module["wasmMemory"]instanceof WebAssembly.Memory)){err("no native wasm Memory in use");return false}env["memory"]=Module["wasmMemory"];info["global"]={"NaN":NaN,"Infinity":Infinity};info["global.Math"]=Math;info["env"]=env;function receiveInstance(instance,module){exports=instance.exports;if(exports.memory)mergeMemory(exports.memory);Module["asm"]=exports;Module["usingWasm"]=true;removeRunDependency("wasm-instantiate");}addRunDependency("wasm-instantiate");if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}function receiveInstantiatedSource(output){receiveInstance(output["instance"],output["module"]);}function instantiateArrayBuffer(receiver){getBinaryPromise().then((function(binary){return WebAssembly.instantiate(binary,info)})).then(receiver).catch((function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);}));}if(!Module["wasmBinary"]&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&typeof fetch==="function"){WebAssembly.instantiateStreaming(fetch(wasmBinaryFile,{credentials:"same-origin"}),info).then(receiveInstantiatedSource).catch((function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");instantiateArrayBuffer(receiveInstantiatedSource);}));}else{instantiateArrayBuffer(receiveInstantiatedSource);}return {}}Module["asmPreload"]=Module["asm"];var asmjsReallocBuffer=Module["reallocBuffer"];var wasmReallocBuffer=(function(size){var PAGE_MULTIPLE=Module["usingWasm"]?WASM_PAGE_SIZE:ASMJS_PAGE_SIZE;size=alignUp(size,PAGE_MULTIPLE);var old=Module["buffer"];var oldSize=old.byteLength;if(Module["usingWasm"]){try{var result=Module["wasmMemory"].grow((size-oldSize)/wasmPageSize);if(result!==(-1|0)){return Module["buffer"]=Module["wasmMemory"].buffer}else{return null}}catch(e){return null}}});Module["reallocBuffer"]=(function(size){{return wasmReallocBuffer(size)}});Module["asm"]=(function(global,env,providedBuffer){env=fixImports(env);if(!env["table"]){var TABLE_SIZE=Module["wasmTableSize"];if(TABLE_SIZE===undefined)TABLE_SIZE=1024;var MAX_TABLE_SIZE=Module["wasmMaxTableSize"];if(typeof WebAssembly==="object"&&typeof WebAssembly.Table==="function"){if(MAX_TABLE_SIZE!==undefined){env["table"]=new WebAssembly.Table({"initial":TABLE_SIZE,"maximum":MAX_TABLE_SIZE,"element":"anyfunc"});}else{env["table"]=new WebAssembly.Table({"initial":TABLE_SIZE,element:"anyfunc"});}}else{env["table"]=new Array(TABLE_SIZE);}Module["wasmTable"]=env["table"];}if(!env["memoryBase"]){env["memoryBase"]=Module["STATIC_BASE"];}if(!env["tableBase"]){env["tableBase"]=0;}var exports;exports=doNativeWasm(global,env,providedBuffer);assert(exports,"no binaryen method succeeded.");return exports});}integrateWasmJS();STATIC_BASE=GLOBAL_BASE;STATICTOP=STATIC_BASE+204768;__ATINIT__.push({func:(function(){__GLOBAL__I_000101();})},{func:(function(){___cxx_global_var_init_2();})},{func:(function(){___cxx_global_var_init_3();})},{func:(function(){___cxx_global_var_init_4();})},{func:(function(){___cxx_global_var_init_5();})},{func:(function(){___cxx_global_var_init_6();})},{func:(function(){__GLOBAL__sub_I_control_cc();})},{func:(function(){__GLOBAL__sub_I_clasp_app_cpp();})},{func:(function(){__GLOBAL__sub_I_clasp_options_cpp();})},{func:(function(){___cxx_global_var_init();})},{func:(function(){___cxx_global_var_init_265();})},{func:(function(){__GLOBAL__sub_I_logic_program_cpp();})},{func:(function(){__GLOBAL__sub_I_shared_context_cpp();})},{func:(function(){__GLOBAL__sub_I_statistics_cpp();})},{func:(function(){___cxx_global_var_init_2409();})},{func:(function(){___cxx_global_var_init_9();})},{func:(function(){___cxx_global_var_init_10();})},{func:(function(){___cxx_global_var_init_11();})},{func:(function(){___cxx_global_var_init_12();})},{func:(function(){___cxx_global_var_init_13();})},{func:(function(){__GLOBAL__sub_I_string_convert_cpp();})},{func:(function(){___emscripten_environ_constructor();})},{func:(function(){__GLOBAL__sub_I_iostream_cpp();})});var STATIC_BUMP=204768;Module["STATIC_BASE"]=STATIC_BASE;Module["STATIC_BUMP"]=STATIC_BUMP;var tempDoublePtr=STATICTOP;STATICTOP+=16;function __exit(status){exit(status);}function _exit(status){__exit(status);}function __Exit(status){__exit(status);}var ENV={};function ___buildEnvironment(environ){var MAX_ENV_VALUES=64;var TOTAL_ENV_SIZE=1024;var poolPtr;var envPtr;if(!___buildEnvironment.called){___buildEnvironment.called=true;ENV["USER"]=ENV["LOGNAME"]="web_user";ENV["PATH"]="/";ENV["PWD"]="/";ENV["HOME"]="/home/web_user";ENV["LANG"]="C.UTF-8";ENV["_"]=Module["thisProgram"];poolPtr=getMemory(TOTAL_ENV_SIZE);envPtr=getMemory(MAX_ENV_VALUES*4);HEAP32[envPtr>>2]=poolPtr;HEAP32[environ>>2]=envPtr;}else{envPtr=HEAP32[environ>>2];poolPtr=HEAP32[envPtr>>2];}var strings=[];var totalSize=0;for(var key in ENV){if(typeof ENV[key]==="string"){var line=key+"="+ENV[key];strings.push(line);totalSize+=line.length;}}if(totalSize>TOTAL_ENV_SIZE){throw new Error("Environment size exceeded TOTAL_ENV_SIZE!")}var ptrSize=4;for(var i=0;i<strings.length;i++){var line=strings[i];writeAsciiToMemory(line,poolPtr);HEAP32[envPtr+i*ptrSize>>2]=poolPtr;poolPtr+=line.length+1;}HEAP32[envPtr+strings.length*ptrSize>>2]=0;}function _emscripten_get_now(){abort();}function _emscripten_get_now_is_monotonic(){return ENVIRONMENT_IS_NODE||typeof dateNow!=="undefined"||(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&self["performance"]&&self["performance"]["now"]}var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now();}else if(clk_id===1&&_emscripten_get_now_is_monotonic()){now=_emscripten_get_now();}else{___setErrNo(ERRNO_CODES.EINVAL);return -1}HEAP32[tp>>2]=now/1e3|0;HEAP32[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function ___clock_gettime(){return _clock_gettime.apply(null,arguments)}function ___cxa_allocate_exception(size){return _malloc(size)}var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:(function(adjusted){if(!adjusted||EXCEPTIONS.infos[adjusted])return adjusted;for(var key in EXCEPTIONS.infos){var ptr=+key;var info=EXCEPTIONS.infos[ptr];if(info.adjusted===adjusted){return ptr}}return adjusted}),addRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount++;}),decRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];assert(info.refcount>0);info.refcount--;if(info.refcount===0&&!info.rethrown){if(info.destructor){Module["dynCall_vi"](info.destructor,ptr);}delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr);}}),clearRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount=0;})};function ___cxa_begin_catch(ptr){var info=EXCEPTIONS.infos[ptr];if(info&&!info.caught){info.caught=true;__ZSt18uncaught_exceptionv.uncaught_exception--;}if(info)info.rethrown=false;EXCEPTIONS.caught.push(ptr);EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));return ptr}function ___cxa_current_primary_exception(){var ret=EXCEPTIONS.caught[EXCEPTIONS.caught.length-1]||0;if(ret)EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ret));return ret}function ___cxa_decrement_exception_refcount(ptr){EXCEPTIONS.decRef(EXCEPTIONS.deAdjust(ptr));}function ___cxa_increment_exception_refcount(ptr){EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));}function ___cxa_pure_virtual(){ABORT=true;throw"Pure virtual function called!"}function ___cxa_free_exception(ptr){try{return _free(ptr)}catch(e){}}function ___cxa_end_catch(){Module["setThrew"](0);var ptr=EXCEPTIONS.caught.pop();if(ptr){EXCEPTIONS.decRef(EXCEPTIONS.deAdjust(ptr));EXCEPTIONS.last=0;}}function ___cxa_rethrow(){var ptr=EXCEPTIONS.caught.pop();ptr=EXCEPTIONS.deAdjust(ptr);if(!EXCEPTIONS.infos[ptr].rethrown){EXCEPTIONS.caught.push(ptr);EXCEPTIONS.infos[ptr].rethrown=true;}EXCEPTIONS.last=ptr;throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_rethrow_primary_exception(ptr){if(!ptr)return;EXCEPTIONS.caught.push(ptr);EXCEPTIONS.infos[ptr].rethrown=true;___cxa_rethrow();}function ___resumeException(ptr){if(!EXCEPTIONS.last){EXCEPTIONS.last=ptr;}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_find_matching_catch(){var thrown=EXCEPTIONS.last;if(!thrown){return (setTempRet0(0),0)|0}var info=EXCEPTIONS.infos[thrown];var throwntype=info.type;if(!throwntype){return (setTempRet0(0),thrown)|0}var typeArray=Array.prototype.slice.call(arguments);var pointer=Module["___cxa_is_pointer_type"](throwntype);if(!___cxa_find_matching_catch.buffer)___cxa_find_matching_catch.buffer=_malloc(4);HEAP32[___cxa_find_matching_catch.buffer>>2]=thrown;thrown=___cxa_find_matching_catch.buffer;for(var i=0;i<typeArray.length;i++){if(typeArray[i]&&Module["___cxa_can_catch"](typeArray[i],throwntype,thrown)){thrown=HEAP32[thrown>>2];info.adjusted=thrown;return (setTempRet0(typeArray[i]),thrown)|0}}thrown=HEAP32[thrown>>2];return (setTempRet0(throwntype),thrown)|0}function ___cxa_throw(ptr,type,destructor){EXCEPTIONS.infos[ptr]={ptr:ptr,adjusted:ptr,type:type,destructor:destructor,refcount:0,caught:false,rethrown:false};EXCEPTIONS.last=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exception=1;}else{__ZSt18uncaught_exceptionv.uncaught_exception++;}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_uncaught_exception(){return !!__ZSt18uncaught_exceptionv.uncaught_exception}function ___gxx_personality_v0(){}function ___lock(){}function ___map_file(pathname,size){___setErrNo(ERRNO_CODES.EPERM);return -1}var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};var PATH={splitPath:(function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)}),normalizeArray:(function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1);}else if(last===".."){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}if(allowAboveRoot){for(;up;up--){parts.unshift("..");}}return parts}),normalize:(function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter((function(p){return !!p})),!isAbsolute).join("/");if(!path&&!isAbsolute){path=".";}if(path&&trailingSlash){path+="/";}return (isAbsolute?"/":"")+path}),dirname:(function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return "."}if(dir){dir=dir.substr(0,dir.length-1);}return root+dir}),basename:(function(path){if(path==="/")return "/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)}),extname:(function(path){return PATH.splitPath(path)[3]}),join:(function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))}),join2:(function(l,r){return PATH.normalize(l+"/"+r)}),resolve:(function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return ""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/";}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter((function(p){return !!p})),!resolvedAbsolute).join("/");return (resolvedAbsolute?"/":"")+resolvedPath||"."}),relative:(function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return [];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..");}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")})};var TTY={ttys:[],init:(function(){}),shutdown:(function(){}),register:(function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops);}),stream_ops:{open:(function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}stream.tty=tty;stream.seekable=false;}),close:(function(stream){stream.tty.ops.flush(stream.tty);}),flush:(function(stream){stream.tty.ops.flush(stream.tty);}),read:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty);}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead}),write:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}for(var i=0;i<length;i++){try{stream.tty.ops.put_char(stream.tty,buffer[offset+i]);}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}}if(length){stream.node.timestamp=Date.now();}return i})},default_tty_ops:{get_char:(function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=new Buffer(BUFSIZE);var bytesRead=0;var isPosixPlatform=process.platform!="win32";var fd=process.stdin.fd;if(isPosixPlatform){var usingDevice=false;try{fd=fs.openSync("/dev/stdin","r");usingDevice=true;}catch(e){}}try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE,null);}catch(e){if(e.toString().indexOf("EOF")!=-1)bytesRead=0;else throw e}if(usingDevice){fs.closeSync(fd);}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8");}else{result=null;}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n";}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n";}}if(!result){return null}tty.input=intArrayFromString(result,true);}return tty.input.shift()}),put_char:(function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[];}else{if(val!=0)tty.output.push(val);}}),flush:(function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[];}})},default_tty1_ops:{put_char:(function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[];}else{if(val!=0)tty.output.push(val);}}),flush:(function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[];}})}};var MEMFS={ops_table:null,mount:(function(mount){return MEMFS.createNode(null,"/",16384|511,0)}),createNode:(function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={};}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null;}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream;}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream;}node.timestamp=Date.now();if(parent){parent.contents[name]=node;}return node}),getFileDataAsRegularArray:(function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents}),getFileDataAsTypedArray:(function(node){if(!node.contents)return new Uint8Array;if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)}),expandFileStorage:(function(node,newCapacity){if(node.contents&&node.contents.subarray&&newCapacity>node.contents.length){node.contents=MEMFS.getFileDataAsRegularArray(node);node.usedBytes=node.contents.length;}if(!node.contents||node.contents.subarray){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return}if(!node.contents&&newCapacity>0)node.contents=[];while(node.contents.length<newCapacity)node.contents.push(0);}),resizeFileStorage:(function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize;}),node_ops:{getattr:(function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096;}else if(FS.isFile(node.mode)){attr.size=node.usedBytes;}else if(FS.isLink(node.mode)){attr.size=node.link.length;}else{attr.size=0;}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size);}}),lookup:(function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT]}),mknod:(function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)}),rename:(function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir;}),unlink:(function(parent,name){delete parent.contents[name];}),rmdir:(function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}delete parent.contents[name];}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries}),symlink:(function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node}),readlink:(function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return node.link})},stream_ops:{read:(function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset);}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];}return size}),write:(function(stream,buffer,offset,length,position,canOwn){if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i];}}node.usedBytes=Math.max(node.usedBytes,position+length);return length}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes;}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position}),allocate:(function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length);}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset;}else{if(position>0||position+length<stream.node.usedBytes){if(contents.subarray){contents=contents.subarray(position,position+length);}else{contents=Array.prototype.slice.call(contents,position,position+length);}}allocated=true;ptr=_malloc(length);if(!ptr){throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)}buffer.set(contents,ptr);}return {ptr:ptr,allocated:allocated}}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0})}};var IDBFS={dbs:{},indexedDB:(function(){if(typeof indexedDB!=="undefined")return indexedDB;var ret=null;if(typeof window==="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;assert(ret,"IDBFS used, but indexedDB not supported");return ret}),DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:(function(mount){return MEMFS.mount.apply(null,arguments)}),syncfs:(function(mount,populate,callback){IDBFS.getLocalSet(mount,(function(err,local){if(err)return callback(err);IDBFS.getRemoteSet(mount,(function(err,remote){if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,callback);}));}));}),getDB:(function(name,callback){var db=IDBFS.dbs[name];if(db){return callback(null,db)}var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION);}catch(e){return callback(e)}if(!req){return callback("Unable to connect to IndexedDB")}req.onupgradeneeded=(function(e){var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME);}else{fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME);}if(!fileStore.indexNames.contains("timestamp")){fileStore.createIndex("timestamp","timestamp",{unique:false});}});req.onsuccess=(function(){db=req.result;IDBFS.dbs[name]=db;callback(null,db);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),getLocalSet:(function(mount,callback){var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return(function(p){return PATH.join2(root,p)})}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path);}catch(e){return callback(e)}if(FS.isDir(stat.mode)){check.push.apply(check,FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));}entries[path]={timestamp:stat.mtime};}return callback(null,{type:"local",entries:entries})}),getRemoteSet:(function(mount,callback){var entries={};IDBFS.getDB(mount.mountpoint,(function(err,db){if(err)return callback(err);try{var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=(function(e){callback(this.error);e.preventDefault();});var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=(function(event){var cursor=event.target.result;if(!cursor){return callback(null,{type:"remote",db:db,entries:entries})}entries[cursor.primaryKey]={timestamp:cursor.key};cursor.continue();});}catch(e){return callback(e)}}));}),loadLocalEntry:(function(path,callback){var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path);}catch(e){return callback(e)}if(FS.isDir(stat.mode)){return callback(null,{timestamp:stat.mtime,mode:stat.mode})}else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);return callback(null,{timestamp:stat.mtime,mode:stat.mode,contents:node.contents})}else{return callback(new Error("node type not supported"))}}),storeLocalEntry:(function(path,entry,callback){try{if(FS.isDir(entry.mode)){FS.mkdir(path,entry.mode);}else if(FS.isFile(entry.mode)){FS.writeFile(path,entry.contents,{canOwn:true});}else{return callback(new Error("node type not supported"))}FS.chmod(path,entry.mode);FS.utime(path,entry.timestamp,entry.timestamp);}catch(e){return callback(e)}callback(null);}),removeLocalEntry:(function(path,callback){try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode)){FS.rmdir(path);}else if(FS.isFile(stat.mode)){FS.unlink(path);}}catch(e){return callback(e)}callback(null);}),loadRemoteEntry:(function(store,path,callback){var req=store.get(path);req.onsuccess=(function(event){callback(null,event.target.result);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),storeRemoteEntry:(function(store,path,entry,callback){var req=store.put(entry,path);req.onsuccess=(function(){callback(null);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),removeRemoteEntry:(function(store,path,callback){var req=store.delete(path);req.onsuccess=(function(){callback(null);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),reconcile:(function(src,dst,callback){var total=0;var create=[];Object.keys(src.entries).forEach((function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e.timestamp>e2.timestamp){create.push(key);total++;}}));var remove=[];Object.keys(dst.entries).forEach((function(key){var e=dst.entries[key];var e2=src.entries[key];if(!e2){remove.push(key);total++;}}));if(!total){return callback(null)}var completed=0;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=total){return callback(null)}}transaction.onerror=(function(e){done(this.error);e.preventDefault();});create.sort().forEach((function(path){if(dst.type==="local"){IDBFS.loadRemoteEntry(store,path,(function(err,entry){if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done);}));}else{IDBFS.loadLocalEntry(path,(function(err,entry){if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done);}));}}));remove.sort().reverse().forEach((function(path){if(dst.type==="local"){IDBFS.removeLocalEntry(path,done);}else{IDBFS.removeRemoteEntry(store,path,done);}}));})};var NODEFS={isWindows:false,staticInit:(function(){NODEFS.isWindows=!!process.platform.match(/^win/);var flags=process["binding"]("constants");if(flags["fs"]){flags=flags["fs"];}NODEFS.flagsForNodeMap={"1024":flags["O_APPEND"],"64":flags["O_CREAT"],"128":flags["O_EXCL"],"0":flags["O_RDONLY"],"2":flags["O_RDWR"],"4096":flags["O_SYNC"],"512":flags["O_TRUNC"],"1":flags["O_WRONLY"]};}),bufferFrom:(function(arrayBuffer){return Buffer.alloc?Buffer.from(arrayBuffer):new Buffer(arrayBuffer)}),mount:(function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)}),createNode:(function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node}),getMode:(function(path){var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&292)>>2;}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return stat.mode}),realPath:(function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent;}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)}),flagsForNode:(function(flags){flags&=~2097152;flags&=~2048;flags&=~32768;flags&=~524288;var newFlags=0;for(var k in NODEFS.flagsForNodeMap){if(flags&k){newFlags|=NODEFS.flagsForNodeMap[k];flags^=k;}}if(!flags){return newFlags}else{throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}}),node_ops:{getattr:(function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096;}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0;}return {dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}}),setattr:(function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode;}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date);}if(attr.size!==undefined){fs.truncateSync(path,attr.size);}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),lookup:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)}),mknod:(function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode);}else{fs.writeFileSync(path,"",{mode:node.mode});}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return node}),rename:(function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),unlink:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),rmdir:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readdir:(function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),symlink:(function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readlink:(function(node){var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}})},stream_ops:{open:(function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsForNode(stream.flags));}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),close:(function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd);}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),read:(function(stream,buffer,offset,length,position){if(length===0)return 0;try{return fs.readSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),write:(function(stream,buffer,offset,length,position){try{return fs.writeSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size;}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:(function(mount){assert(ENVIRONMENT_IS_WORKER);if(!WORKERFS.reader)WORKERFS.reader=new FileReaderSync;var root=WORKERFS.createNode(null,"/",WORKERFS.DIR_MODE,0);var createdParents={};function ensureParent(path){var parts=path.split("/");var parent=root;for(var i=0;i<parts.length-1;i++){var curr=parts.slice(0,i+1).join("/");if(!createdParents[curr]){createdParents[curr]=WORKERFS.createNode(parent,parts[i],WORKERFS.DIR_MODE,0);}parent=createdParents[curr];}return parent}function base(path){var parts=path.split("/");return parts[parts.length-1]}Array.prototype.forEach.call(mount.opts["files"]||[],(function(file){WORKERFS.createNode(ensureParent(file.name),base(file.name),WORKERFS.FILE_MODE,0,file,file.lastModifiedDate);}));(mount.opts["blobs"]||[]).forEach((function(obj){WORKERFS.createNode(ensureParent(obj["name"]),base(obj["name"]),WORKERFS.FILE_MODE,0,obj["data"]);}));(mount.opts["packages"]||[]).forEach((function(pack){pack["metadata"].files.forEach((function(file){var name=file.filename.substr(1);WORKERFS.createNode(ensureParent(name),base(name),WORKERFS.FILE_MODE,0,pack["blob"].slice(file.start,file.end));}));}));return root}),createNode:(function(parent,name,mode,dev,contents,mtime){var node=FS.createNode(parent,name,mode);node.mode=mode;node.node_ops=WORKERFS.node_ops;node.stream_ops=WORKERFS.stream_ops;node.timestamp=(mtime||new Date).getTime();assert(WORKERFS.FILE_MODE!==WORKERFS.DIR_MODE);if(mode===WORKERFS.FILE_MODE){node.size=contents.size;node.contents=contents;}else{node.size=4096;node.contents={};}if(parent){parent.contents[name]=node;}return node}),node_ops:{getattr:(function(node){return {dev:1,ino:undefined,mode:node.mode,nlink:1,uid:0,gid:0,rdev:undefined,size:node.size,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:Math.ceil(node.size/4096)}}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}}),lookup:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}),mknod:(function(parent,name,mode,dev){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rename:(function(oldNode,newDir,newName){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),unlink:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rmdir:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries}),symlink:(function(parent,newName,oldPath){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readlink:(function(node){throw new FS.ErrnoError(ERRNO_CODES.EPERM)})},stream_ops:{read:(function(stream,buffer,offset,length,position){if(position>=stream.node.size)return 0;var chunk=stream.node.contents.slice(position,position+length);var ab=WORKERFS.reader.readAsArrayBuffer(chunk);buffer.set(new Uint8Array(ab),offset);return chunk.size}),write:(function(stream,buffer,offset,length,position){throw new FS.ErrnoError(ERRNO_CODES.EIO)}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.size;}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};STATICTOP+=16;STATICTOP+=16;STATICTOP+=16;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:(function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)}),lookupPath:(function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};if(!path)return {path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key];}}if(opts.recurse_count>8){throw new FS.ErrnoError(ERRNO_CODES.ELOOP)}var parts=PATH.normalizeArray(path.split("/").filter((function(p){return !!p})),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root;}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(ERRNO_CODES.ELOOP)}}}}return {path:current_path,node:current}}),getPath:(function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent;}}),hashName:(function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0;}return (parentid+hash>>>0)%FS.nameTable.length}),hashAddNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node;}),hashRemoveNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next;}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next;}}}),lookupNode:(function(parent,name){var err=FS.mayLookup(parent);if(err){throw new FS.ErrnoError(err,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)}),createNode:(function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=(function(parent,name,mode,rdev){if(!parent){parent=this;}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;});FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:(function(){return (this.mode&readMode)===readMode}),set:(function(val){val?this.mode|=readMode:this.mode&=~readMode;})},write:{get:(function(){return (this.mode&writeMode)===writeMode}),set:(function(val){val?this.mode|=writeMode:this.mode&=~writeMode;})},isFolder:{get:(function(){return FS.isDir(this.mode)})},isDevice:{get:(function(){return FS.isChrdev(this.mode)})}});}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node}),destroyNode:(function(node){FS.hashRemoveNode(node);}),isRoot:(function(node){return node===node.parent}),isMountpoint:(function(node){return !!node.mounted}),isFile:(function(mode){return (mode&61440)===32768}),isDir:(function(mode){return (mode&61440)===16384}),isLink:(function(mode){return (mode&61440)===40960}),isChrdev:(function(mode){return (mode&61440)===8192}),isBlkdev:(function(mode){return (mode&61440)===24576}),isFIFO:(function(mode){return (mode&61440)===4096}),isSocket:(function(mode){return (mode&49152)===49152}),flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:(function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags}),flagsToPermissionString:(function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w";}return perms}),nodePermissions:(function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return ERRNO_CODES.EACCES}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return ERRNO_CODES.EACCES}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return ERRNO_CODES.EACCES}return 0}),mayLookup:(function(dir){var err=FS.nodePermissions(dir,"x");if(err)return err;if(!dir.node_ops.lookup)return ERRNO_CODES.EACCES;return 0}),mayCreate:(function(dir,name){try{var node=FS.lookupNode(dir,name);return ERRNO_CODES.EEXIST}catch(e){}return FS.nodePermissions(dir,"wx")}),mayDelete:(function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name);}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err){return err}if(isdir){if(!FS.isDir(node.mode)){return ERRNO_CODES.ENOTDIR}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return ERRNO_CODES.EBUSY}}else{if(FS.isDir(node.mode)){return ERRNO_CODES.EISDIR}}return 0}),mayOpen:(function(node,flags){if(!node){return ERRNO_CODES.ENOENT}if(FS.isLink(node.mode)){return ERRNO_CODES.ELOOP}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return ERRNO_CODES.EISDIR}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))}),MAX_OPEN_FDS:4096,nextfd:(function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(ERRNO_CODES.EMFILE)}),getStream:(function(fd){return FS.streams[fd]}),createStream:(function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=(function(){});FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:(function(){return this.node}),set:(function(val){this.node=val;})},isRead:{get:(function(){return (this.flags&2097155)!==1})},isWrite:{get:(function(){return (this.flags&2097155)!==0})},isAppend:{get:(function(){return this.flags&1024})}});}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p];}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream}),closeStream:(function(fd){FS.streams[fd]=null;}),chrdev_stream_ops:{open:(function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream);}}),llseek:(function(){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)})},major:(function(dev){return dev>>8}),minor:(function(dev){return dev&255}),makedev:(function(ma,mi){return ma<<8|mi}),registerDevice:(function(dev,ops){FS.devices[dev]={stream_ops:ops};}),getDevice:(function(dev){return FS.devices[dev]}),getMounts:(function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts);}return mounts}),syncfs:(function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false;}FS.syncFSRequests++;if(FS.syncFSRequests>1){console.log("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(err){assert(FS.syncFSRequests>0);FS.syncFSRequests--;return callback(err)}function done(err){if(err){if(!done.errored){done.errored=true;return doCallback(err)}return}if(++completed>=mounts.length){doCallback(null);}}mounts.forEach((function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done);}));}),mount:(function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot;}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount);}}return mountRoot}),unmount:(function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach((function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current);}current=next;}}));node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1);}),lookup:(function(parent,name){return parent.node_ops.lookup(parent,name)}),mknod:(function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var err=FS.mayCreate(parent,name);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return parent.node_ops.mknod(parent,name,mode,dev)}),create:(function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)}),mkdir:(function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)}),mkdirTree:(function(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode);}catch(e){if(e.errno!=ERRNO_CODES.EEXIST)throw e}}}),mkdev:(function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438;}mode|=8192;return FS.mknod(path,mode,dev)}),symlink:(function(oldpath,newpath){if(!PATH.resolve(oldpath)){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return parent.node_ops.symlink(parent,newname,oldpath)}),rename:(function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(!old_dir||!new_dir)throw new FS.ErrnoError(ERRNO_CODES.ENOENT);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(ERRNO_CODES.EXDEV)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err){throw new FS.ErrnoError(err)}err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err){throw new FS.ErrnoError(err)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err){throw new FS.ErrnoError(err)}}try{}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message);}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);}catch(e){throw e}finally{FS.hashAddNode(old_node);}try{}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message);}}),rmdir:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}try{}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message);}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message);}}),readdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}return node.node_ops.readdir(node)}),unlink:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}try{}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message);}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message);}}),readlink:(function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!link.node_ops.readlink){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return PATH.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))}),stat:(function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!node.node_ops.getattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return node.node_ops.getattr(node)}),lstat:(function(path){return FS.stat(path,true)}),chmod:(function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else{node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()});}),lchmod:(function(path,mode){FS.chmod(path,mode,true);}),fchmod:(function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}FS.chmod(stream.node,mode);}),chown:(function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else{node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}node.node_ops.setattr(node,{timestamp:Date.now()});}),lchown:(function(path,uid,gid){FS.chown(path,uid,gid,true);}),fchown:(function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}FS.chown(stream.node,uid,gid);}),truncate:(function(path,len){if(len<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;}else{node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var err=FS.nodePermissions(node,"w");if(err){throw new FS.ErrnoError(err)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()});}),ftruncate:(function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}FS.truncate(stream.node,len);}),utime:(function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)});}),open:(function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768;}else{mode=0;}var node;if(typeof path==="object"){node=path;}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node;}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(ERRNO_CODES.EEXIST)}}else{node=FS.mknod(path,mode,0);created=true;}}if(!node){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(FS.isChrdev(node.mode)){flags&=~512;}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}if(!created){var err=FS.mayOpen(node,flags);if(err){throw new FS.ErrnoError(err)}}if(flags&512){FS.truncate(node,0);}flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream);}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;err("read file: "+path);}}try{}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message);}return stream}),close:(function(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream);}}catch(e){throw e}finally{FS.closeStream(stream.fd);}stream.fd=null;}),isClosed:(function(stream){return stream.fd===null}),llseek:(function(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position}),read:(function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(FS.isClosed(stream)){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!stream.stream_ops.read){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead}),write:(function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(FS.isClosed(stream)){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!stream.stream_ops.write){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(stream.flags&1024){FS.llseek(stream,0,2);}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path);}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: "+e.message);}return bytesWritten}),allocate:(function(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(offset<0||length<=0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)}stream.stream_ops.allocate(stream,offset,length);}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1){throw new FS.ErrnoError(ERRNO_CODES.EACCES)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)}),munmap:(function(stream){return 0}),ioctl:(function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)}return stream.stream_ops.ioctl(stream,cmd,arg)}),readFile:(function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0);}else if(opts.encoding==="binary"){ret=buf;}FS.close(stream);return ret}),writeFile:(function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn);}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn);}else{throw new Error("Unsupported data type")}FS.close(stream);}),cwd:(function(){return FS.currentPath}),chdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}var err=FS.nodePermissions(lookup.node,"x");if(err){throw new FS.ErrnoError(err)}FS.currentPath=lookup.path;}),createDefaultDirectories:(function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user");}),createDefaultDevices:(function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:(function(){return 0}),write:(function(stream,buffer,offset,length,pos){return length})});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device;if(typeof crypto!=="undefined"){var randomBuffer=new Uint8Array(1);random_device=(function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]});}else if(ENVIRONMENT_IS_NODE){random_device=(function(){return require$$0["randomBytes"](1)[0]});}else{random_device=(function(){return Math.random()*256|0});}FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp");}),createSpecialDirectories:(function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:(function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:(function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:(function(){return stream.path})}};ret.parent=ret;return ret})};return node})},{},"/proc/self/fd");}),createStandardStreams:(function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"]);}else{FS.symlink("/dev/tty","/dev/stdin");}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"]);}else{FS.symlink("/dev/tty","/dev/stdout");}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"]);}else{FS.symlink("/dev/tty1","/dev/stderr");}var stdin=FS.open("/dev/stdin","r");assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");var stdout=FS.open("/dev/stdout","w");assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");var stderr=FS.open("/dev/stderr","w");assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")");}),ensureErrnoError:(function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=(function(errno){this.errno=errno;for(var key in ERRNO_CODES){if(ERRNO_CODES[key]===errno){this.code=key;break}}});this.setErrno(errno);this.message=ERRNO_MESSAGES[errno];if(this.stack)Object.defineProperty(this,"stack",{value:(new Error).stack,writable:true});};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[ERRNO_CODES.ENOENT].forEach((function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>";}));}),staticInit:(function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"IDBFS":IDBFS,"NODEFS":NODEFS,"WORKERFS":WORKERFS};}),init:(function(input,output,error){assert(!FS.init.initialized,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams();}),quit:(function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream);}}),getMode:(function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode}),joinPath:(function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path}),absolutePath:(function(relative,base){return PATH.resolve(base,relative)}),standardizePath:(function(path){return PATH.normalize(path)}),findObject:(function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{___setErrNo(ret.error);return null}}),analyzePath:(function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path;}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/";}catch(e){ret.error=e.errno;}return ret}),createFolder:(function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)}),createPath:(function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current);}catch(e){}parent=current;}return current}),createFile:(function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)}),createDataFile:(function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr;}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode);}return node}),createDevice:(function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:(function(stream){stream.seekable=false;}),close:(function(stream){if(output&&output.buffer&&output.buffer.length){output(10);}}),read:(function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input();}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead}),write:(function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i]);}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}}if(length){stream.node.timestamp=Date.now();}return i})});return FS.mkdev(path,mode,dev)}),createLink:(function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)}),forceLoadFile:(function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(Module["read"]){try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length;}catch(e){success=false;}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)___setErrNo(ERRNO_CODES.EIO);return success}),createLazyFile:(function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[];}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter;};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined");}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||"",true)}});var lazyArray=this;lazyArray.setDataGetter((function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end);}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]}));if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;console.log("LazyFiles on gzip forces download of the whole file when length is accessed");}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true;};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:(function(){if(!this.lengthKnown){this.cacheLength();}return this._length})},chunkSize:{get:(function(){if(!this.lengthKnown){this.cacheLength();}return this._chunkSize})}});var properties={isDevice:false,contents:lazyArray};}else{var properties={isDevice:false,url:url};}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents;}else if(properties.url){node.contents=null;node.url=properties.url;}Object.defineProperties(node,{usedBytes:{get:(function(){return this.contents.length})}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach((function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(ERRNO_CODES.EIO)}return fn.apply(null,arguments)};}));stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(ERRNO_CODES.EIO)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i];}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i);}}return size};node.stream_ops=stream_ops;return node}),createPreloadedFile:(function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);}if(onload)onload();removeRunDependency(dep);}var handled=false;Module["preloadPlugins"].forEach((function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,(function(){if(onerror)onerror();removeRunDependency(dep);}));handled=true;}}));if(!handled)finish(byteArray);}addRunDependency(dep);if(typeof url=="string"){Browser.asyncLoad(url,(function(byteArray){processData(byteArray);}),onerror);}else{processData(url);}}),indexedDB:(function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB}),DB_NAME:(function(){return "EM_FS_"+window.location.pathname}),DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME);};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach((function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish();};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish();};}));transaction.onerror=onerror;};openRequest.onerror=onerror;}),loadFilesFromDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly");}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach((function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path);}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish();};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish();};}));transaction.onerror=onerror;};openRequest.onerror=onerror;})};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:(function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd();}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);dir=dirstream.path;}path=PATH.join2(dir,path);}return path}),doStat:(function(func,path,buf){try{var stat=func(path);}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return -ERRNO_CODES.ENOTDIR}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;HEAP32[buf+36>>2]=stat.size;HEAP32[buf+40>>2]=4096;HEAP32[buf+44>>2]=stat.blocks;HEAP32[buf+48>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+52>>2]=0;HEAP32[buf+56>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ino;return 0}),doMsync:(function(addr,stream,len,flags){var buffer=new Uint8Array(HEAPU8.subarray(addr,addr+len));FS.msync(stream,buffer,0,len,flags);}),doMkdir:(function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0}),doMknod:(function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return -ERRNO_CODES.EINVAL}FS.mknod(path,mode,dev);return 0}),doReadlink:(function(path,buf,bufsize){if(bufsize<=0)return -ERRNO_CODES.EINVAL;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}),doAccess:(function(path,amode){if(amode&~7){return -ERRNO_CODES.EINVAL}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return -ERRNO_CODES.EACCES}return 0}),doDup:(function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd}),doReadv:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;if(curr<len)break}return ret}),doWritev:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;}return ret}),varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),getStreamFromFD:(function(){var stream=FS.getStream(SYSCALLS.get());if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return stream}),getSocketFromFD:(function(){var socket=SOCKFS.getSocket(SYSCALLS.get());if(!socket)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return socket}),getSocketAddress:(function(allowNull){var addrp=SYSCALLS.get(),addrlen=SYSCALLS.get();if(allowNull&&addrp===0)return null;var info=__read_sockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0);})};function ___syscall10(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr();FS.unlink(path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall145(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doReadv(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doWritev(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall196(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr(),buf=SYSCALLS.get();return SYSCALLS.doStat(FS.lstat,path,buf)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall221(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),cmd=SYSCALLS.get();switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return -ERRNO_CODES.EINVAL}var newStream;newStream=FS.open(stream.path,stream.flags,0,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 12:case 12:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 13:case 14:case 13:case 14:return 0;case 16:case 8:return -ERRNO_CODES.EINVAL;case 9:___setErrNo(ERRNO_CODES.EINVAL);return -1;default:{return -ERRNO_CODES.EINVAL}}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall330(which,varargs){SYSCALLS.varargs=varargs;try{var old=SYSCALLS.getStreamFromFD(),suggestFD=SYSCALLS.get(),flags=SYSCALLS.get();assert(!flags);if(old.fd===suggestFD)return -ERRNO_CODES.EINVAL;return SYSCALLS.doDup(old.path,old.flags,suggestFD)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall38(which,varargs){SYSCALLS.varargs=varargs;try{var old_path=SYSCALLS.getStr(),new_path=SYSCALLS.getStr();FS.rename(old_path,new_path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall40(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr();FS.rmdir(path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall5(which,varargs){SYSCALLS.varargs=varargs;try{var pathname=SYSCALLS.getStr(),flags=SYSCALLS.get(),mode=SYSCALLS.get();var stream=FS.open(pathname,flags,mode);return stream.fd}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),op=SYSCALLS.get();switch(op){case 21509:case 21505:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0}case 21519:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0}case 21520:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return -ERRNO_CODES.EINVAL}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0}case 21524:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0}default:abort("bad ioctl syscall "+op);}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall63(which,varargs){SYSCALLS.varargs=varargs;try{var old=SYSCALLS.getStreamFromFD(),suggestFD=SYSCALLS.get();if(old.fd===suggestFD)return suggestFD;return SYSCALLS.doDup(old.path,old.flags,suggestFD)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall77(which,varargs){SYSCALLS.varargs=varargs;try{var who=SYSCALLS.get(),usage=SYSCALLS.get();_memset(usage,0,136);HEAP32[usage>>2]=1;HEAP32[usage+4>>2]=2;HEAP32[usage+8>>2]=3;HEAP32[usage+12>>2]=4;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall91(which,varargs){SYSCALLS.varargs=varargs;try{var addr=SYSCALLS.get(),len=SYSCALLS.get();var info=SYSCALLS.mappings[addr];if(!info)return 0;if(len===info.len){var stream=FS.getStream(info.fd);SYSCALLS.doMsync(addr,stream,len,info.flags);SYSCALLS.mappings[addr]=null;if(info.allocated){_free(info.malloc);}}return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___unlock(){}function ___wait(){}function _abort(){Module["abort"]();}var __sigalrm_handler=0;function _alarm(seconds){setTimeout((function(){if(__sigalrm_handler)Module["dynCall_vi"](__sigalrm_handler,0);}),seconds*1e3);}function _clock(){if(_clock.start===undefined)_clock.start=Date.now();return (Date.now()-_clock.start)*(1e6/1e3)|0}function _difftime(time1,time0){return time1-time0}function _getenv(name){if(name===0)return 0;name=Pointer_stringify(name);if(!ENV.hasOwnProperty(name))return 0;if(_getenv.ret)_free(_getenv.ret);_getenv.ret=allocateUTF8(ENV[name]);return _getenv.ret}function _gettimeofday(ptr){var now=Date.now();HEAP32[ptr>>2]=now/1e3|0;HEAP32[ptr+4>>2]=now%1e3*1e3|0;return 0}var ___tm_current=STATICTOP;STATICTOP+=48;var ___tm_timezone=allocate(intArrayFromString("GMT"),"i8",ALLOC_STATIC);function _gmtime_r(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();HEAP32[tmPtr+36>>2]=0;HEAP32[tmPtr+32>>2]=0;var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+40>>2]=___tm_timezone;return tmPtr}function _gmtime(time){return _gmtime_r(time,___tm_current)}var _llvm_ceil_f32=Math_ceil;var _llvm_ceil_f64=Math_ceil;function _llvm_exp2_f32(x){return Math.pow(2,x)}function _llvm_exp2_f64(){return _llvm_exp2_f32.apply(null,arguments)}var _llvm_fabs_f64=Math_abs;var _llvm_floor_f64=Math_floor;function _llvm_log10_f32(x){return Math.log(x)/Math.LN10}function _llvm_log10_f64(){return _llvm_log10_f32.apply(null,arguments)}function _llvm_stackrestore(p){var self=_llvm_stacksave;var ret=self.LLVM_SAVEDSTACKS[p];self.LLVM_SAVEDSTACKS.splice(p,1);stackRestore(ret);}function _llvm_stacksave(){var self=_llvm_stacksave;if(!self.LLVM_SAVEDSTACKS){self.LLVM_SAVEDSTACKS=[];}self.LLVM_SAVEDSTACKS.push(stackSave());return self.LLVM_SAVEDSTACKS.length-1}function _llvm_trap(){abort("trap!");}function _tzset(){if(_tzset.called)return;_tzset.called=true;HEAP32[__get_timezone()>>2]=(new Date).getTimezoneOffset()*60;var winter=new Date(2e3,0,1);var summer=new Date(2e3,6,1);HEAP32[__get_daylight()>>2]=Number(winter.getTimezoneOffset()!=summer.getTimezoneOffset());function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocate(intArrayFromString(winterName),"i8",ALLOC_NORMAL);var summerNamePtr=allocate(intArrayFromString(summerName),"i8",ALLOC_NORMAL);if(summer.getTimezoneOffset()<winter.getTimezoneOffset()){HEAP32[__get_tzname()>>2]=winterNamePtr;HEAP32[__get_tzname()+4>>2]=summerNamePtr;}else{HEAP32[__get_tzname()>>2]=summerNamePtr;HEAP32[__get_tzname()+4>>2]=winterNamePtr;}}function _localtime_r(time,tmPtr){_tzset();var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=(new Date(2e3,6,1)).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst;var zonePtr=HEAP32[__get_tzname()+(dst?4:0)>>2];HEAP32[tmPtr+40>>2]=zonePtr;return tmPtr}function _localtime(time){return _localtime_r(time,___tm_current)}function _longjmp(env,value){Module["setThrew"](env,value||1);throw"longjmp"}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function _mktime(tmPtr){_tzset();var date=new Date(HEAP32[tmPtr+20>>2]+1900,HEAP32[tmPtr+16>>2],HEAP32[tmPtr+12>>2],HEAP32[tmPtr+8>>2],HEAP32[tmPtr+4>>2],HEAP32[tmPtr>>2],0);var dst=HEAP32[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=(new Date(2e3,6,1)).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){HEAP32[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset);}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4);}HEAP32[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;return date.getTime()/1e3|0}function _pthread_cond_wait(){return 0}var PTHREAD_SPECIFIC={};function _pthread_getspecific(key){return PTHREAD_SPECIFIC[key]||0}var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key,destructor){if(key==0){return ERRNO_CODES.EINVAL}HEAP32[key>>2]=PTHREAD_SPECIFIC_NEXT_KEY;PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY]=0;PTHREAD_SPECIFIC_NEXT_KEY++;return 0}function _pthread_mutex_destroy(){}function _pthread_once(ptr,func){if(!_pthread_once.seen)_pthread_once.seen={};if(ptr in _pthread_once.seen)return;Module["dynCall_v"](func);_pthread_once.seen[ptr]=1;}function _pthread_setspecific(key,value){if(!(key in PTHREAD_SPECIFIC)){return ERRNO_CODES.EINVAL}PTHREAD_SPECIFIC[key]=value;return 0}function _signal(sig,func){if(sig==14){__sigalrm_handler=func;}return 0}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]);return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1);}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1);}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?Pointer_stringify(tm_zone):""};var pattern=Pointer_stringify(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule]);}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value==="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str;}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate());}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":(function(date){return WEEKDAYS[date.tm_wday].substring(0,3)}),"%A":(function(date){return WEEKDAYS[date.tm_wday]}),"%b":(function(date){return MONTHS[date.tm_mon].substring(0,3)}),"%B":(function(date){return MONTHS[date.tm_mon]}),"%C":(function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)}),"%d":(function(date){return leadingNulls(date.tm_mday,2)}),"%e":(function(date){return leadingSomething(date.tm_mday,2," ")}),"%g":(function(date){return getWeekBasedYear(date).toString().substring(2)}),"%G":(function(date){return getWeekBasedYear(date)}),"%H":(function(date){return leadingNulls(date.tm_hour,2)}),"%I":(function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)}),"%j":(function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)}),"%m":(function(date){return leadingNulls(date.tm_mon+1,2)}),"%M":(function(date){return leadingNulls(date.tm_min,2)}),"%n":(function(){return "\n"}),"%p":(function(date){if(date.tm_hour>=0&&date.tm_hour<12){return "AM"}else{return "PM"}}),"%S":(function(date){return leadingNulls(date.tm_sec,2)}),"%t":(function(){return "\t"}),"%u":(function(date){var day=new Date(date.tm_year+1900,date.tm_mon+1,date.tm_mday,0,0,0,0);return day.getDay()||7}),"%U":(function(date){var janFirst=new Date(date.tm_year+1900,0,1);var firstSunday=janFirst.getDay()===0?janFirst:__addDays(janFirst,7-janFirst.getDay());var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstSunday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstSundayUntilEndJanuary=31-firstSunday.getDate();var days=firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstSunday,janFirst)===0?"01":"00"}),"%V":(function(date){var janFourthThisYear=new Date(date.tm_year+1900,0,4);var janFourthNextYear=new Date(date.tm_year+1901,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);var endDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);if(compareByDay(endDate,firstWeekStartThisYear)<0){return "53"}if(compareByDay(firstWeekStartNextYear,endDate)<=0){return "01"}var daysDifference;if(firstWeekStartThisYear.getFullYear()<date.tm_year+1900){daysDifference=date.tm_yday+32-firstWeekStartThisYear.getDate();}else{daysDifference=date.tm_yday+1-firstWeekStartThisYear.getDate();}return leadingNulls(Math.ceil(daysDifference/7),2)}),"%w":(function(date){var day=new Date(date.tm_year+1900,date.tm_mon+1,date.tm_mday,0,0,0,0);return day.getDay()}),"%W":(function(date){var janFirst=new Date(date.tm_year,0,1);var firstMonday=janFirst.getDay()===1?janFirst:__addDays(janFirst,janFirst.getDay()===0?1:7-janFirst.getDay()+1);var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstMonday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstMondayUntilEndJanuary=31-firstMonday.getDate();var days=firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstMonday,janFirst)===0?"01":"00"}),"%y":(function(date){return (date.tm_year+1900).toString().substring(2)}),"%Y":(function(date){return date.tm_year+1900}),"%z":(function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return (ahead?"+":"-")+String("0000"+off).slice(-4)}),"%Z":(function(date){return date.tm_zone}),"%%":(function(){return "%"})};for(var rule in EXPANSION_RULES_2){if(pattern.indexOf(rule)>=0){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date));}}var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _system(command){___setErrNo(ERRNO_CODES.EAGAIN);return -1}function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){HEAP32[ptr>>2]=ret;}return ret}if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function _emscripten_get_now_actual(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6};}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow;}else if(typeof self==="object"&&self["performance"]&&typeof self["performance"]["now"]==="function"){_emscripten_get_now=(function(){return self["performance"]["now"]()});}else if(typeof performance==="object"&&typeof performance["now"]==="function"){_emscripten_get_now=(function(){return performance["now"]()});}else{_emscripten_get_now=Date.now;}FS.staticInit();__ATINIT__.unshift((function(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();}));__ATMAIN__.push((function(){FS.ignorePermissions=false;}));__ATEXIT__.push((function(){FS.quit();}));__ATINIT__.unshift((function(){}));__ATEXIT__.push((function(){}));if(ENVIRONMENT_IS_NODE){var fs=require$$0;var NODEJS_PATH=require$$1;NODEFS.staticInit();}DYNAMICTOP_PTR=staticAlloc(4);STACK_BASE=STACKTOP=alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}Module["wasmTableSize"]=7612;Module["wasmMaxTableSize"]=7612;function invoke_di(index,a1){var sp=stackSave();try{return Module["dynCall_di"](index,a1)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_didi(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_didi"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_diii(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_diii"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_dij(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_dij"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_ii(index,a1){var sp=stackSave();try{return Module["dynCall_ii"](index,a1)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iid(index,a1,a2){var sp=stackSave();try{return Module["dynCall_iid"](index,a1,a2)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return Module["dynCall_iii"](index,a1,a2)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiid(index,a1,a2,a3,a4){var sp=stackSave();try{return Module["dynCall_iiiid"](index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return Module["dynCall_iiiii"](index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_iiiiid"](index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiiid(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return Module["dynCall_iiiiiid"](index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return Module["dynCall_iiiiiii"](index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return Module["dynCall_iiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{return Module["dynCall_iiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiij(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return Module["dynCall_iiiiij"](index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iij(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_iij"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiji(index,a1,a2,a3,a4){var sp=stackSave();try{return Module["dynCall_iiji"](index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iijii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_iijii"](index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iijj(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_iijj"](index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_ijii(index,a1,a2,a3,a4){var sp=stackSave();try{return Module["dynCall_ijii"](index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_ijiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_ijiii"](index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_ijiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return Module["dynCall_ijiiii"](index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_ji(index,a1){var sp=stackSave();try{return Module["dynCall_ji"](index,a1)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_jii(index,a1,a2){var sp=stackSave();try{return Module["dynCall_jii"](index,a1,a2)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_jiii(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_jiii"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_jij(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_jij"](index,a1,a2,a3)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_jiji(index,a1,a2,a3,a4){var sp=stackSave();try{return Module["dynCall_jiji"](index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_jijii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_jijii"](index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_v(index){var sp=stackSave();try{Module["dynCall_v"](index);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_vi(index,a1){var sp=stackSave();try{Module["dynCall_vi"](index,a1);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_vii(index,a1,a2){var sp=stackSave();try{Module["dynCall_vii"](index,a1,a2);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{Module["dynCall_viii"](index,a1,a2,a3);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{Module["dynCall_viiii"](index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{Module["dynCall_viiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viijii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{Module["dynCall_viijii"](index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_vijd(index,a1,a2,a3,a4){var sp=stackSave();try{Module["dynCall_vijd"](index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}Module.asmGlobalArg={};Module.asmLibraryArg={"abort":abort,"assert":assert,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"invoke_di":invoke_di,"invoke_didi":invoke_didi,"invoke_diii":invoke_diii,"invoke_dij":invoke_dij,"invoke_ii":invoke_ii,"invoke_iid":invoke_iid,"invoke_iii":invoke_iii,"invoke_iiii":invoke_iiii,"invoke_iiiid":invoke_iiiid,"invoke_iiiii":invoke_iiiii,"invoke_iiiiid":invoke_iiiiid,"invoke_iiiiii":invoke_iiiiii,"invoke_iiiiiid":invoke_iiiiiid,"invoke_iiiiiii":invoke_iiiiiii,"invoke_iiiiiiii":invoke_iiiiiiii,"invoke_iiiiiiiii":invoke_iiiiiiiii,"invoke_iiiiij":invoke_iiiiij,"invoke_iij":invoke_iij,"invoke_iiji":invoke_iiji,"invoke_iijii":invoke_iijii,"invoke_iijj":invoke_iijj,"invoke_ijii":invoke_ijii,"invoke_ijiii":invoke_ijiii,"invoke_ijiiii":invoke_ijiiii,"invoke_ji":invoke_ji,"invoke_jii":invoke_jii,"invoke_jiii":invoke_jiii,"invoke_jij":invoke_jij,"invoke_jiji":invoke_jiji,"invoke_jijii":invoke_jijii,"invoke_v":invoke_v,"invoke_vi":invoke_vi,"invoke_vii":invoke_vii,"invoke_viii":invoke_viii,"invoke_viiii":invoke_viiii,"invoke_viiiii":invoke_viiiii,"invoke_viiiiii":invoke_viiiiii,"invoke_viiiiiii":invoke_viiiiiii,"invoke_viijii":invoke_viijii,"invoke_vijd":invoke_vijd,"__Exit":__Exit,"___buildEnvironment":___buildEnvironment,"___clock_gettime":___clock_gettime,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_begin_catch":___cxa_begin_catch,"___cxa_current_primary_exception":___cxa_current_primary_exception,"___cxa_decrement_exception_refcount":___cxa_decrement_exception_refcount,"___cxa_end_catch":___cxa_end_catch,"___cxa_find_matching_catch":___cxa_find_matching_catch,"___cxa_free_exception":___cxa_free_exception,"___cxa_increment_exception_refcount":___cxa_increment_exception_refcount,"___cxa_pure_virtual":___cxa_pure_virtual,"___cxa_rethrow":___cxa_rethrow,"___cxa_rethrow_primary_exception":___cxa_rethrow_primary_exception,"___cxa_throw":___cxa_throw,"___cxa_uncaught_exception":___cxa_uncaught_exception,"___gxx_personality_v0":___gxx_personality_v0,"___lock":___lock,"___map_file":___map_file,"___resumeException":___resumeException,"___setErrNo":___setErrNo,"___syscall10":___syscall10,"___syscall140":___syscall140,"___syscall145":___syscall145,"___syscall146":___syscall146,"___syscall196":___syscall196,"___syscall221":___syscall221,"___syscall330":___syscall330,"___syscall38":___syscall38,"___syscall40":___syscall40,"___syscall5":___syscall5,"___syscall54":___syscall54,"___syscall6":___syscall6,"___syscall63":___syscall63,"___syscall77":___syscall77,"___syscall91":___syscall91,"___unlock":___unlock,"___wait":___wait,"__addDays":__addDays,"__arraySum":__arraySum,"__exit":__exit,"__isLeapYear":__isLeapYear,"_abort":_abort,"_alarm":_alarm,"_clock":_clock,"_clock_gettime":_clock_gettime,"_difftime":_difftime,"_emscripten_get_now":_emscripten_get_now,"_emscripten_get_now_is_monotonic":_emscripten_get_now_is_monotonic,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_exit":_exit,"_getenv":_getenv,"_gettimeofday":_gettimeofday,"_gmtime":_gmtime,"_gmtime_r":_gmtime_r,"_llvm_ceil_f32":_llvm_ceil_f32,"_llvm_ceil_f64":_llvm_ceil_f64,"_llvm_exp2_f32":_llvm_exp2_f32,"_llvm_exp2_f64":_llvm_exp2_f64,"_llvm_fabs_f64":_llvm_fabs_f64,"_llvm_floor_f64":_llvm_floor_f64,"_llvm_log10_f32":_llvm_log10_f32,"_llvm_log10_f64":_llvm_log10_f64,"_llvm_stackrestore":_llvm_stackrestore,"_llvm_stacksave":_llvm_stacksave,"_llvm_trap":_llvm_trap,"_localtime":_localtime,"_localtime_r":_localtime_r,"_longjmp":_longjmp,"_mktime":_mktime,"_pthread_cond_wait":_pthread_cond_wait,"_pthread_getspecific":_pthread_getspecific,"_pthread_key_create":_pthread_key_create,"_pthread_mutex_destroy":_pthread_mutex_destroy,"_pthread_once":_pthread_once,"_pthread_setspecific":_pthread_setspecific,"_signal":_signal,"_strftime":_strftime,"_strftime_l":_strftime_l,"_system":_system,"_time":_time,"_tzset":_tzset,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX};var asm=Module["asm"](Module.asmGlobalArg,Module.asmLibraryArg,buffer);Module["asm"]=asm;var __GLOBAL__I_000101=Module["__GLOBAL__I_000101"]=(function(){return Module["asm"]["__GLOBAL__I_000101"].apply(null,arguments)});var __GLOBAL__sub_I_clasp_app_cpp=Module["__GLOBAL__sub_I_clasp_app_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_clasp_app_cpp"].apply(null,arguments)});var __GLOBAL__sub_I_clasp_options_cpp=Module["__GLOBAL__sub_I_clasp_options_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_clasp_options_cpp"].apply(null,arguments)});var __GLOBAL__sub_I_control_cc=Module["__GLOBAL__sub_I_control_cc"]=(function(){return Module["asm"]["__GLOBAL__sub_I_control_cc"].apply(null,arguments)});var __GLOBAL__sub_I_iostream_cpp=Module["__GLOBAL__sub_I_iostream_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_iostream_cpp"].apply(null,arguments)});var __GLOBAL__sub_I_logic_program_cpp=Module["__GLOBAL__sub_I_logic_program_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_logic_program_cpp"].apply(null,arguments)});var __GLOBAL__sub_I_shared_context_cpp=Module["__GLOBAL__sub_I_shared_context_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_shared_context_cpp"].apply(null,arguments)});var __GLOBAL__sub_I_statistics_cpp=Module["__GLOBAL__sub_I_statistics_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_statistics_cpp"].apply(null,arguments)});var __GLOBAL__sub_I_string_convert_cpp=Module["__GLOBAL__sub_I_string_convert_cpp"]=(function(){return Module["asm"]["__GLOBAL__sub_I_string_convert_cpp"].apply(null,arguments)});var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=(function(){return Module["asm"]["__ZSt18uncaught_exceptionv"].apply(null,arguments)});var ___cxa_can_catch=Module["___cxa_can_catch"]=(function(){return Module["asm"]["___cxa_can_catch"].apply(null,arguments)});var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=(function(){return Module["asm"]["___cxa_is_pointer_type"].apply(null,arguments)});var ___cxx_global_var_init=Module["___cxx_global_var_init"]=(function(){return Module["asm"]["___cxx_global_var_init"].apply(null,arguments)});var ___cxx_global_var_init_10=Module["___cxx_global_var_init_10"]=(function(){return Module["asm"]["___cxx_global_var_init_10"].apply(null,arguments)});var ___cxx_global_var_init_11=Module["___cxx_global_var_init_11"]=(function(){return Module["asm"]["___cxx_global_var_init_11"].apply(null,arguments)});var ___cxx_global_var_init_12=Module["___cxx_global_var_init_12"]=(function(){return Module["asm"]["___cxx_global_var_init_12"].apply(null,arguments)});var ___cxx_global_var_init_13=Module["___cxx_global_var_init_13"]=(function(){return Module["asm"]["___cxx_global_var_init_13"].apply(null,arguments)});var ___cxx_global_var_init_2=Module["___cxx_global_var_init_2"]=(function(){return Module["asm"]["___cxx_global_var_init_2"].apply(null,arguments)});var ___cxx_global_var_init_2409=Module["___cxx_global_var_init_2409"]=(function(){return Module["asm"]["___cxx_global_var_init_2409"].apply(null,arguments)});var ___cxx_global_var_init_265=Module["___cxx_global_var_init_265"]=(function(){return Module["asm"]["___cxx_global_var_init_265"].apply(null,arguments)});var ___cxx_global_var_init_3=Module["___cxx_global_var_init_3"]=(function(){return Module["asm"]["___cxx_global_var_init_3"].apply(null,arguments)});var ___cxx_global_var_init_4=Module["___cxx_global_var_init_4"]=(function(){return Module["asm"]["___cxx_global_var_init_4"].apply(null,arguments)});var ___cxx_global_var_init_5=Module["___cxx_global_var_init_5"]=(function(){return Module["asm"]["___cxx_global_var_init_5"].apply(null,arguments)});var ___cxx_global_var_init_6=Module["___cxx_global_var_init_6"]=(function(){return Module["asm"]["___cxx_global_var_init_6"].apply(null,arguments)});var ___cxx_global_var_init_9=Module["___cxx_global_var_init_9"]=(function(){return Module["asm"]["___cxx_global_var_init_9"].apply(null,arguments)});var ___emscripten_environ_constructor=Module["___emscripten_environ_constructor"]=(function(){return Module["asm"]["___emscripten_environ_constructor"].apply(null,arguments)});var ___errno_location=Module["___errno_location"]=(function(){return Module["asm"]["___errno_location"].apply(null,arguments)});var __get_daylight=Module["__get_daylight"]=(function(){return Module["asm"]["__get_daylight"].apply(null,arguments)});var __get_environ=Module["__get_environ"]=(function(){return Module["asm"]["__get_environ"].apply(null,arguments)});var __get_timezone=Module["__get_timezone"]=(function(){return Module["asm"]["__get_timezone"].apply(null,arguments)});var __get_tzname=Module["__get_tzname"]=(function(){return Module["asm"]["__get_tzname"].apply(null,arguments)});var _emscripten_replace_memory=Module["_emscripten_replace_memory"]=(function(){return Module["asm"]["_emscripten_replace_memory"].apply(null,arguments)});var _free=Module["_free"]=(function(){return Module["asm"]["_free"].apply(null,arguments)});var _llvm_bswap_i32=Module["_llvm_bswap_i32"]=(function(){return Module["asm"]["_llvm_bswap_i32"].apply(null,arguments)});var _malloc=Module["_malloc"]=(function(){return Module["asm"]["_malloc"].apply(null,arguments)});var _memcpy=Module["_memcpy"]=(function(){return Module["asm"]["_memcpy"].apply(null,arguments)});var _memmove=Module["_memmove"]=(function(){return Module["asm"]["_memmove"].apply(null,arguments)});var _memset=Module["_memset"]=(function(){return Module["asm"]["_memset"].apply(null,arguments)});var _pthread_cond_broadcast=Module["_pthread_cond_broadcast"]=(function(){return Module["asm"]["_pthread_cond_broadcast"].apply(null,arguments)});var _pthread_mutex_lock=Module["_pthread_mutex_lock"]=(function(){return Module["asm"]["_pthread_mutex_lock"].apply(null,arguments)});var _pthread_mutex_unlock=Module["_pthread_mutex_unlock"]=(function(){return Module["asm"]["_pthread_mutex_unlock"].apply(null,arguments)});var _realloc=Module["_realloc"]=(function(){return Module["asm"]["_realloc"].apply(null,arguments)});var _run=Module["_run"]=(function(){return Module["asm"]["_run"].apply(null,arguments)});var _saveSetjmp=Module["_saveSetjmp"]=(function(){return Module["asm"]["_saveSetjmp"].apply(null,arguments)});var _sbrk=Module["_sbrk"]=(function(){return Module["asm"]["_sbrk"].apply(null,arguments)});var _testSetjmp=Module["_testSetjmp"]=(function(){return Module["asm"]["_testSetjmp"].apply(null,arguments)});var establishStackSpace=Module["establishStackSpace"]=(function(){return Module["asm"]["establishStackSpace"].apply(null,arguments)});var getTempRet0=Module["getTempRet0"]=(function(){return Module["asm"]["getTempRet0"].apply(null,arguments)});var runPostSets=Module["runPostSets"]=(function(){return Module["asm"]["runPostSets"].apply(null,arguments)});var setTempRet0=Module["setTempRet0"]=(function(){return Module["asm"]["setTempRet0"].apply(null,arguments)});var setThrew=Module["setThrew"]=(function(){return Module["asm"]["setThrew"].apply(null,arguments)});var stackAlloc=Module["stackAlloc"]=(function(){return Module["asm"]["stackAlloc"].apply(null,arguments)});var stackRestore=Module["stackRestore"]=(function(){return Module["asm"]["stackRestore"].apply(null,arguments)});var stackSave=Module["stackSave"]=(function(){return Module["asm"]["stackSave"].apply(null,arguments)});var dynCall_di=Module["dynCall_di"]=(function(){return Module["asm"]["dynCall_di"].apply(null,arguments)});var dynCall_didi=Module["dynCall_didi"]=(function(){return Module["asm"]["dynCall_didi"].apply(null,arguments)});var dynCall_diii=Module["dynCall_diii"]=(function(){return Module["asm"]["dynCall_diii"].apply(null,arguments)});var dynCall_dij=Module["dynCall_dij"]=(function(){return Module["asm"]["dynCall_dij"].apply(null,arguments)});var dynCall_ii=Module["dynCall_ii"]=(function(){return Module["asm"]["dynCall_ii"].apply(null,arguments)});var dynCall_iid=Module["dynCall_iid"]=(function(){return Module["asm"]["dynCall_iid"].apply(null,arguments)});var dynCall_iii=Module["dynCall_iii"]=(function(){return Module["asm"]["dynCall_iii"].apply(null,arguments)});var dynCall_iiii=Module["dynCall_iiii"]=(function(){return Module["asm"]["dynCall_iiii"].apply(null,arguments)});var dynCall_iiiid=Module["dynCall_iiiid"]=(function(){return Module["asm"]["dynCall_iiiid"].apply(null,arguments)});var dynCall_iiiii=Module["dynCall_iiiii"]=(function(){return Module["asm"]["dynCall_iiiii"].apply(null,arguments)});var dynCall_iiiiid=Module["dynCall_iiiiid"]=(function(){return Module["asm"]["dynCall_iiiiid"].apply(null,arguments)});var dynCall_iiiiii=Module["dynCall_iiiiii"]=(function(){return Module["asm"]["dynCall_iiiiii"].apply(null,arguments)});var dynCall_iiiiiid=Module["dynCall_iiiiiid"]=(function(){return Module["asm"]["dynCall_iiiiiid"].apply(null,arguments)});var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=(function(){return Module["asm"]["dynCall_iiiiiii"].apply(null,arguments)});var dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=(function(){return Module["asm"]["dynCall_iiiiiiii"].apply(null,arguments)});var dynCall_iiiiiiiii=Module["dynCall_iiiiiiiii"]=(function(){return Module["asm"]["dynCall_iiiiiiiii"].apply(null,arguments)});var dynCall_iiiiij=Module["dynCall_iiiiij"]=(function(){return Module["asm"]["dynCall_iiiiij"].apply(null,arguments)});var dynCall_iij=Module["dynCall_iij"]=(function(){return Module["asm"]["dynCall_iij"].apply(null,arguments)});var dynCall_iiji=Module["dynCall_iiji"]=(function(){return Module["asm"]["dynCall_iiji"].apply(null,arguments)});var dynCall_iijii=Module["dynCall_iijii"]=(function(){return Module["asm"]["dynCall_iijii"].apply(null,arguments)});var dynCall_iijj=Module["dynCall_iijj"]=(function(){return Module["asm"]["dynCall_iijj"].apply(null,arguments)});var dynCall_ijii=Module["dynCall_ijii"]=(function(){return Module["asm"]["dynCall_ijii"].apply(null,arguments)});var dynCall_ijiii=Module["dynCall_ijiii"]=(function(){return Module["asm"]["dynCall_ijiii"].apply(null,arguments)});var dynCall_ijiiii=Module["dynCall_ijiiii"]=(function(){return Module["asm"]["dynCall_ijiiii"].apply(null,arguments)});var dynCall_ji=Module["dynCall_ji"]=(function(){return Module["asm"]["dynCall_ji"].apply(null,arguments)});var dynCall_jii=Module["dynCall_jii"]=(function(){return Module["asm"]["dynCall_jii"].apply(null,arguments)});var dynCall_jiii=Module["dynCall_jiii"]=(function(){return Module["asm"]["dynCall_jiii"].apply(null,arguments)});var dynCall_jij=Module["dynCall_jij"]=(function(){return Module["asm"]["dynCall_jij"].apply(null,arguments)});var dynCall_jiji=Module["dynCall_jiji"]=(function(){return Module["asm"]["dynCall_jiji"].apply(null,arguments)});var dynCall_jijii=Module["dynCall_jijii"]=(function(){return Module["asm"]["dynCall_jijii"].apply(null,arguments)});var dynCall_v=Module["dynCall_v"]=(function(){return Module["asm"]["dynCall_v"].apply(null,arguments)});var dynCall_vi=Module["dynCall_vi"]=(function(){return Module["asm"]["dynCall_vi"].apply(null,arguments)});var dynCall_vii=Module["dynCall_vii"]=(function(){return Module["asm"]["dynCall_vii"].apply(null,arguments)});var dynCall_viii=Module["dynCall_viii"]=(function(){return Module["asm"]["dynCall_viii"].apply(null,arguments)});var dynCall_viiii=Module["dynCall_viiii"]=(function(){return Module["asm"]["dynCall_viiii"].apply(null,arguments)});var dynCall_viiiii=Module["dynCall_viiiii"]=(function(){return Module["asm"]["dynCall_viiiii"].apply(null,arguments)});var dynCall_viiiiii=Module["dynCall_viiiiii"]=(function(){return Module["asm"]["dynCall_viiiiii"].apply(null,arguments)});var dynCall_viiiiiii=Module["dynCall_viiiiiii"]=(function(){return Module["asm"]["dynCall_viiiiiii"].apply(null,arguments)});var dynCall_viijii=Module["dynCall_viijii"]=(function(){return Module["asm"]["dynCall_viijii"].apply(null,arguments)});var dynCall_vijd=Module["dynCall_vijd"]=(function(){return Module["asm"]["dynCall_vijd"].apply(null,arguments)});Module["asm"]=asm;Module["ccall"]=ccall;Module["then"]=(function(func){if(Module["calledRun"]){func(Module);}else{var old=Module["onRuntimeInitialized"];Module["onRuntimeInitialized"]=(function(){if(old)old();func(Module);});}return Module});function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller;};function run(args){args=args||Module["arguments"];if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("");}),1);doRun();}),1);}else{doRun();}}Module["run"]=run;function exit(status,implicit){if(implicit&&Module["noExitRuntime"]&&status===0){return}if(Module["noExitRuntime"]);else{ABORT=true;STACKTOP=initialStackTop;exitRuntime();if(Module["onExit"])Module["onExit"](status);}Module["quit"](status,new ExitStatus(status));}function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}if(what!==undefined){out(what);err(what);what=JSON.stringify(what);}else{what="";}ABORT=true;throw"abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}Module["noExitRuntime"]=true;run();





      return Module;
    }
    );
    })();
    module.exports = Module;
    });

    const SOFT_REGEX = /(soft\(\w+).*?\)/;
    /**
     * Get the array of witnesses from clingo output.
     * Return undefined if no witnesses were found.
     */
    function getModels(result, constraints$$1) {
        return (result.Call || []).reduce((arr, el) => {
            el.Witnesses.forEach((d) => {
                const facts = d.Value;
                const costs = d.Costs;
                const violationAsps = facts.filter((fact) => {
                    return fact.startsWith('soft(');
                });
                const violations = violationAsps.map((asp) => {
                    const matcher = SOFT_REGEX.exec(asp);
                    if (!matcher) {
                        throw Error(`invalid violation: ${asp}`);
                    }
                    const toMatch = matcher[1];
                    const constraint = constraints$$1.find((curr) => {
                        return curr.asp.startsWith(toMatch);
                    });
                    if (!constraint) {
                        throw Error(`${toMatch} not found!`);
                    }
                    return Object.assign({}, constraint, { witness: asp });
                });
                arr.push({
                    costs,
                    facts,
                    violations,
                });
            });
            return arr;
        }, []);
    }
    function models2vl(models) {
        return models.map(model => asp2vl(model.facts));
    }

    /**
     * Draco is a solver that recommends visualization specifications based off
     * partial specs.
     */
    class Draco {
        /**
         * @param url The base path of the server hosting this.
         * @param updateStatus Optional callback to log updates for status changes.
         */
        constructor(url = 'https://unpkg.com/wasm-clingo@0.2.2', updateStatus = console.log) {
            this.initialized = false;
            this.stdout = '';
            // add / if it's missing from the URL
            if (url.substr(url.length - 1) !== '/') {
                url += '/';
            }
            const that = this;
            const m = {
                // Where to locate clingo.wasm
                locateFile: (file) => `${url}${file}`,
                // Status change logger
                setStatus: updateStatus,
                print(text) {
                    that.stdout += text;
                },
                // Dependencies
                totalDependencies: 0,
                monitorRunDependencies(left) {
                    m.totalDependencies = Math.max(m.totalDependencies, left);
                    m.setStatus(left
                        ? 'Preparing... (' + (m.totalDependencies - left) + '/' + m.totalDependencies + ')'
                        : 'All downloads complete.');
                },
                printErr(err) {
                    if (err) {
                        m.setStatus('Received output on stderr.');
                        console.warn(err);
                    }
                },
            };
            this.Module = m;
            this.schema = null;
            this.hard = constraints2json(HARD);
            this.soft = constraints2json(SOFT, WEIGHTS);
            this.constraints = constraints;
        }
        /**
         * Initializes the underlying solver.
         *
         * @returns A promise that resolves when the solver is ready.
         */
        init() {
            return new Promise((resolve, reject) => {
                this.Module.setStatus('Downloading...');
                this.Module.onRuntimeInitialized = () => {
                    this.initialized = true;
                    resolve(this);
                };
                clingo(this.Module);
            });
        }
        /**
         * Solves with the given constraints.
         *
         * @param program The constraint to solve (e.g. the partial specification in ASP)
         * @param options Options for solving.
         *
         * @returns The solution from Clingo as JSON.
         */
        solve(program, options = {}) {
            if (!this.initialized) {
                throw Error('Draco is not initialized. Call `init() first.`');
            }
            this.Module.setStatus('Running Draco Query...');
            const dataDecl = this.getDataDeclaration();
            program += dataDecl;
            const programs = options.constraints ||
                Object.keys(this.constraints).filter(name => !(name === 'SOFT' || name === 'HARD' || name === 'WEIGHTS'));
            if (options.relaxHard && programs.indexOf('HARD_INTEGRITY') !== -1) {
                programs.splice(programs.indexOf('HARD_INTEGRITY'), 1);
            }
            program += programs.map((name) => this.constraints[name]).join('\n\n');
            const softAsp = json2constraints(this.soft);
            const hardAsp = json2constraints(this.hard);
            program += hardAsp.definitions + '\n\n';
            program += softAsp.definitions + '\n\n' + softAsp.weights + '\n\n' + softAsp.assigns;
            const opt = [
                '--outf=2',
                '--opt-mode=OptN',
                '--quiet=1',
                '--project',
                options.models === undefined ? 1 : options.models,
            ]
                .concat((options.weights || []).map(d => `-c ${d.name}=${d.value}`))
                .join(' ');
            // reset stdout before running clingo
            this.stdout = '';
            this.Module.ccall('run', 'number', ['string', 'string'], [program, opt]);
            const result = JSON.parse(this.stdout);
            if (result.Result === 'UNSATISFIABLE') {
                console.debug('UNSATISFIABLE');
                console.debug(result);
                return null;
            }
            const models = getModels(result, this.soft.concat(this.hard));
            if (models.length > (options.models || 1)) {
                throw new Error('Too many models.');
            }
            const specs = models2vl(models);
            // done
            this.Module.setStatus('');
            return { models, programs, specs, result };
        }
        getSchema() {
            return this.schema;
        }
        prepareData(data) {
            this.schema = data2schema(data);
        }
        updateAsp(aspSet) {
            this.constraints = Object.assign({}, this.constraints, aspSet);
        }
        getConstraintSet() {
            return {
                soft: this.soft,
                hard: this.hard,
            };
        }
        setConstraintSet(constraintSet) {
            this.hard = constraintSet.hard;
            this.soft = constraintSet.soft;
        }
        getDataDeclaration() {
            if (!this.schema) {
                return '';
            }
            return schema2asp(this.schema).join('\n');
        }
    }

    exports.default = Draco;
    exports.getModels = getModels;
    exports.models2vl = models2vl;
    exports.vl2asp = vl2asp;
    exports.asp2vl = asp2vl;
    exports.cql2asp = cql2asp;
    exports.data2schema = data2schema;
    exports.schema2asp = schema2asp;
    exports.constraints = constraints;
    exports.constraints2json = constraints2json;
    exports.json2constraints = json2constraints;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=draco.js.map
